<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>直播源检测 v1.4.1</title>
    <style>
/* 基础重置 */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

/* 整体样式 */
body {
    font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif;
    margin: 0;
    padding: 12px;
    background: linear-gradient(135deg, #f5f7fa 0%, #e4e8f0 100%);
    min-height: 100vh;
    color: #333;
    line-height: 1.5;
    font-size: 14px;
    display: flex;
    flex-direction: column;
    height: 100vh;
    overflow: hidden;
    opacity: 0;
    transition: opacity 0.3s ease;
}

/* 容器 */
.container {
    display: flex;
    flex-direction: column;
    flex: 1;
    gap: 12px;
    max-height: calc(100vh - 24px);
}

/* 顶部区域 */
.top-section {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 12px;
    flex-shrink: 0;
}

/* 底部区域 */
.bottom-section {
    flex: 1;
    min-height: 0;
    display: flex;
    flex-direction: column;
}

/* 卡片样式优化 */
.card {
    background: white;
    border-radius: 12px;
    padding: 16px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
    border: 1px solid rgba(255, 255, 255, 0.2);
    transition: transform 0.3s ease, box-shadow 0.3s ease;
    position: relative;
    overflow: hidden;
}

.card:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(0, 0, 0, 0.12);
}

.card::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 4px;
    background: linear-gradient(90deg, #2c80ff, #1a5bbf);
    border-radius: 12px 12px 0 0;
}

/* 标题样式 */
h2 {
    margin: 0 0 12px 0;
    color: #1a5bbf;
    font-size: 1.2rem;
    font-weight: 600;
    position: relative;
    padding-left: 8px;
}

h2::before {
    content: '';
    position: absolute;
    left: 0;
    top: 50%;
    transform: translateY(-50%);
    width: 3px;
    height: 18px;
    background: linear-gradient(180deg, #2c80ff, #4c9cff);
    border-radius: 2px;
}

h3 {
    font-size: 1rem;
    margin: 0 0 8px 0;
    color: #2d3748;
}

/* 头部区域 */
.header-card {
    grid-column: 1 / -1;
}

/* 控制区域 - 简化 */
.controls-card {
    display: flex;
    flex-direction: column;
    height: 100%;
    grid-column: 1 / -1; /* 控制区域占满整行 */
}

/* 预览区域 - 已移除 */
.preview-card {
    display: none; /* 隐藏视频预览区域 */
}

/* 视频播放弹窗 - 修改为悬浮模式 */
.video-modal {
    position: fixed;
    top: 20px;
    left: 50%;
    transform: translateX(-50%);
    background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
    border-radius: 12px;
    width: 95%;
    max-width: 800px;
    max-height: 70vh;
    display: none;
    flex-direction: column;
    box-shadow: 0 10px 50px rgba(0, 0, 0, 0.7);
    z-index: 1000;
    overflow: hidden;
    border: 2px solid rgba(255, 255, 255, 0.1);
    opacity: 0;
    animation: modalSlideIn 0.3s ease forwards;
}

@keyframes modalSlideIn {
    from {
        opacity: 0;
        transform: translateX(-50%) translateY(-20px);
    }
    to {
        opacity: 1;
        transform: translateX(-50%) translateY(0);
    }
}

.video-modal.show {
    display: flex;
}

/* 移除遮罩层，让背景内容可交互 */
.video-modal-backdrop {
    display: none; /* 不需要遮罩层 */
}

.video-modal-header {
    padding: 12px 16px;
    background: rgba(0, 0, 0, 0.7);
    display: flex;
    justify-content: space-between;
    align-items: center;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    flex-shrink: 0;
}

.video-modal-title {
    color: white;
    font-weight: 600;
    font-size: 14px;
    display: flex;
    align-items: center;
    gap: 8px;
}

.video-modal-status {
    font-size: 11px;
    color: white;
    padding: 3px 6px;
    border-radius: 10px;
    font-weight: 500;
}

.video-modal-status.playing {
    background: linear-gradient(135deg, #38a169 0%, #2f855a 100%);
}

.video-modal-status.error {
    background: linear-gradient(135deg, #e53e3e 0%, #c53030 100%);
}

.video-modal-status.idle {
    background: linear-gradient(135deg, #a0aec0 0%, #718096 100%);
}

.video-modal-status.loading {
    background: linear-gradient(135deg, #2c80ff 0%, #1a5bbf 100%);
}

.close-video-modal {
    background: none;
    border: none;
    color: rgba(255, 255, 255, 0.7);
    font-size: 20px;
    cursor: pointer;
    width: 28px;
    height: 28px;
    border-radius: 6px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s ease;
    flex-shrink: 0;
}

.close-video-modal:hover {
    background: rgba(255, 255, 255, 0.1);
    color: white;
}

.video-modal-body {
    flex: 1;
    display: flex;
    flex-direction: column;
    padding: 16px;
    overflow: hidden;
    min-height: 0;
}

.video-player-container {
    flex: 1;
    display: flex;
    flex-direction: column;
    background: #000;
    border-radius: 8px;
    overflow: hidden;
    position: relative;
    min-height: 200px;
}

.video-player-container video {
    width: 100%;
    height: 100%;
    max-height: 50vh;
    object-fit: contain;
    background: #000;
}

.video-info {
    padding: 8px;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 6px;
    margin-top: 8px;
    color: rgba(255, 255, 255, 0.8);
    font-size: 12px;
    flex-shrink: 0;
}

.video-controls {
    display: flex;
    gap: 8px;
    margin-top: 8px;
    flex-shrink: 0;
}

.video-controls button {
    padding: 8px 12px;
    border-radius: 6px;
    font-size: 13px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
    border: none;
}

.video-stop-btn {
    background: linear-gradient(135deg, #e53e3e 0%, #c53030 100%);
    color: white;
    flex: 1;
}

.video-stop-btn:hover {
    background: linear-gradient(135deg, #c53030 0%, #9b2c2c 100%);
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(229, 62, 62, 0.3);
}

/* 列表区域 */
.list-card {
    flex: 1;
    min-height: 0;
    display: flex;
    flex-direction: column;
}

/* 表单元素样式优化 */
input, select, button, textarea {
    padding: 10px;
    border: 2px solid #e1e5eb;
    border-radius: 8px;
    font-size: 14px;
    font-family: inherit;
    transition: all 0.3s ease;
    outline: none;
}

input:focus, select:focus, textarea:focus {
    border-color: #2c80ff;
    box-shadow: 0 0 0 3px rgba(44, 128, 255, 0.1);
}

input::placeholder {
    color: #a0aec0;
}

/* 按钮样式优化 - 增大字体 */
button {
    background: linear-gradient(135deg, #2c80ff 0%, #1a5bbf 100%);
    color: white;
    border: none;
    cursor: pointer;
    font-weight: 600;
    padding: 10px 16px;
    border-radius: 8px;
    transition: all 0.3s ease;
    position: relative;
    overflow: hidden;
    font-size: 16px; /* 增大按钮字体 */
}

button::after {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    width: 0;
    height: 0;
    border-radius: 50%;
    background: rgba(255, 255, 255, 0.2);
    transform: translate(-50%, -50%);
    transition: width 0.6s, height 0.6s;
}

button:hover::after {
    width: 200px;
    height: 200px;
}

button:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(44, 128, 255, 0.3);
}

button:active {
    transform: translateY(0);
}

button:disabled {
    background: linear-gradient(135deg, #cbd5e0 0%, #a0aec0 100%);
    cursor: not-allowed;
    transform: none !important;
    box-shadow: none !important;
}

/* 统计区域优化 */
.stats {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 8px;
    margin-top: 12px;
}

.stat {
    padding: 12px;
    background: linear-gradient(135deg, #f8fafc 0%, #edf2f7 100%);
    border-radius: 8px;
    border: 1px solid #e2e8f0;
    transition: transform 0.3s ease;
    text-align: center;
}

.stat:hover {
    transform: translateY(-2px);
}

.stat-value {
    font-size: 24px;
    font-weight: 700;
    background: linear-gradient(135deg, #2c80ff, #4c9cff);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    margin-bottom: 4px;
}

.stat-label {
    font-size: 11px;
    color: #718096;
    font-weight: 500;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

/* 通知样式优化 */
.notification {
    position: fixed;
    top: 12px;
    right: 12px;
    padding: 12px 16px;
    background: linear-gradient(135deg, #38a169 0%, #2f855a 100%);
    color: white;
    border-radius: 8px;
    display: none;
    z-index: 1000;
    box-shadow: 0 4px 12px rgba(56, 161, 105, 0.3);
    animation: slideIn 0.3s ease;
    border-left: 3px solid #68d391;
    font-size: 13px;
    max-width: 300px;
}

@keyframes slideIn {
    from {
        transform: translateX(100%);
        opacity: 0;
    }
    to {
        transform: translateX(0);
        opacity: 1;
    }
}

/* 播放器容器优化 - 已移除 */

/* 直播源列表优化 */
.source-list-container {
    flex: 1;
    display: flex;
    flex-direction: column;
    min-height: 0;
}

.source-list {
    flex: 1;
    overflow-y: auto;
    margin: 12px 0;
    border-radius: 8px;
    border: 1px solid #e2e8f0;
    background: white;
}

.source-item {
    display: flex;
    align-items: center;
    padding: 12px;
    margin: 0;
    background: white;
    border-bottom: 1px solid #f1f5f9;
    transition: all 0.3s ease;
    position: relative;
}

.source-item:hover {
    background: linear-gradient(90deg, rgba(44, 128, 255, 0.05) 0%, rgba(44, 128, 255, 0.02) 100%);
    transform: translateX(2px);
}

.source-item:last-child {
    border-bottom: none;
}

.channel-name {
    font-weight: 600;
    font-size: 14px;
    margin-bottom: 4px;
    color: #2d3748;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 200px;
}

.channel-url {
    font-size: 12px;
    color: #718096;
    word-break: break-all;
    margin-bottom: 4px;
    font-family: 'Consolas', monospace;
    max-height: 36px;
    overflow: hidden;
    text-overflow: ellipsis;
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
}

/* 进度条优化 */
.progress {
    background: #e2e8f0;
    border-radius: 8px;
    height: 10px;
    margin: 12px 0;
    overflow: hidden;
    box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.1);
}

.progress-bar {
    background: linear-gradient(90deg, #2c80ff 0%, #4c9cff 100%);
    height: 100%;
    width: 0%;
    transition: width 0.5s cubic-bezier(0.4, 0, 0.2, 1);
    position: relative;
    overflow: hidden;
}

.progress-bar::after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(90deg, 
        transparent 0%, 
        rgba(255, 255, 255, 0.4) 50%, 
        transparent 100%);
    animation: shimmer 2s infinite;
}

@keyframes shimmer {
    0% { transform: translateX(-100%); }
    100% { transform: translateX(100%); }
}

/* 筛选按钮优化 */
.filter-buttons {
    display: flex;
    gap: 8px;
    margin-bottom: 12px;
}

.filter-btn {
    padding: 8px 12px;
    background: linear-gradient(135deg, #edf2f7 0%, #e2e8f0 100%);
    color: #4a5568;
    border-radius: 6px;
    cursor: pointer;
    font-weight: 500;
    border: 2px solid transparent;
    transition: all 0.3s ease;
    font-size: 14px; /* 增大筛选按钮字体 */
    flex: 1;
}

.filter-btn:hover {
    transform: translateY(-1px);
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
}

.filter-btn.active {
    background: linear-gradient(135deg, #2c80ff 0%, #1a5bbf 100%);
    color: white;
    border-color: #2c80ff;
    box-shadow: 0 2px 8px rgba(44, 128, 255, 0.3);
}

/* 版本徽章优化 */
.version-badge {
    position: fixed;
    top: 12px;
    right: 12px;
    background: linear-gradient(135deg, #2c80ff 0%, #1a5bbf 100%);
    color: white;
    padding: 4px 8px;
    border-radius: 12px;
    font-size: 11px;
    font-weight: 600;
    z-index: 100;
    box-shadow: 0 2px 8px rgba(44, 128, 255, 0.3);
    border: 2px solid white;
}

/* 播放状态优化 - 已移动到弹窗 */

/* 播放控制优化 - 已移动到弹窗 */

/* 队列状态优化 */
.queue-status {
    background: linear-gradient(135deg, #f8fafc 0%, #edf2f7 100%);
    border-radius: 8px;
    padding: 12px;
    margin: 8px 0;
    border: 1px solid #e2e8f0;
    font-size: 12px;
}

.queue-item {
    display: inline-block;
    width: 22px;
    height: 22px;
    line-height: 22px;
    text-align: center;
    border-radius: 6px;
    margin: 2px;
    font-size: 11px;
    font-weight: 600;
    background: #e2e8f0;
    color: #718096;
    transition: all 0.3s ease;
}

.queue-item.active {
    background: linear-gradient(135deg, #2c80ff 0%, #1a5bbf 100%);
    color: white;
    transform: scale(1.1);
}

.queue-item.pending {
    background: linear-gradient(135deg, #f6ad55 0%, #ed8936 100%);
    color: white;
}

.queue-item.success {
    background: linear-gradient(135deg, #38a169 0%, #2f855a 100%);
    color: white;
}

.queue-item.failed {
    background: linear-gradient(135deg, #e53e3e 0%, #c53030 100%);
    color: white;
}

/* 紧凑布局优化 */
.compact-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 16px;
    padding-bottom: 12px;
    border-bottom: 1px solid #e2e8f0;
}

.compact-header h2 {
    margin: 0;
}

/* 导入容器优化 */
.compact-import-container {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 12px;
    margin-bottom: 16px;
}

.import-section-compact {
    background: linear-gradient(135deg, #f8fafc 0%, #edf2f7 100%);
    border-radius: 8px;
    padding: 16px;
    border: 1px solid #e2e8f0;
    transition: transform 0.3s ease;
}

.import-section-compact:hover {
    transform: translateY(-2px);
}

.import-section-title {
    font-size: 14px;
    font-weight: 600;
    color: #2c80ff;
    margin-bottom: 12px;
    padding-bottom: 8px;
    border-bottom: 1px solid #e2e8f0;
}

.file-import-row, .url-import-row {
    display: flex;
    gap: 8px;
    margin-bottom: 12px;
}

.file-import-row input[type="file"] {
    flex: 1;
    padding: 8px;
    background: white;
    cursor: pointer;
    font-size: 13px;
}

.file-import-row input[type="file"]::file-selector-button {
    background: linear-gradient(135deg, #2c80ff 0%, #1a5bbf 100%);
    color: white;
    border: none;
    padding: 6px 10px;
    border-radius: 6px;
    cursor: pointer;
    margin-right: 8px;
    font-size: 12px;
}

.url-import-row input {
    flex: 1;
    min-width: 0;
    font-size: 13px;
}

/* 分组选择器优化 */
.group-selector-section {
    margin-top: 12px;
    padding-top: 12px;
    border-top: 1px solid #e2e8f0;
}

.group-selector-btn {
    width: 100%;
    padding: 10px;
    background: white;
    border: 2px solid #e1e5eb;
    border-radius: 8px;
    font-size: 14px; /* 增大分组选择器按钮字体 */
    color: #4a5568;
    cursor: pointer;
    display: flex;
    justify-content: space-between;
    align-items: center;
    transition: all 0.3s ease;
    position: relative;
    overflow: hidden;
}

.group-selector-btn:hover {
    border-color: #2c80ff;
    box-shadow: 0 2px 8px rgba(44, 128, 255, 0.1);
}

.group-selector-btn:disabled {
    opacity: 0.6;
    cursor: not-allowed;
    background: #f5f5f5;
}

.group-selector-text {
    flex: 1;
    text-align: left;
    overflow: hidden;
    white-space: nowrap;
    text-overflow: ellipsis;
    margin-right: 8px;
}

.group-selector-arrow {
    font-size: 10px;
    color: #718096;
    transition: transform 0.3s ease;
}

/* 检测设置弹窗 */
.settings-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.5);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 2000;
    opacity: 0;
    visibility: hidden;
    transition: all 0.3s ease;
}

.settings-modal.show {
    opacity: 1;
    visibility: visible;
}

.settings-content {
    background: white;
    border-radius: 12px;
    width: 90%;
    max-width: 500px;
    max-height: 80vh;
    display: flex;
    flex-direction: column;
    box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
    transform: translateY(20px);
    transition: transform 0.3s ease;
}

.settings-modal.show .settings-content {
    transform: translateY(0);
}

.settings-header {
    padding: 20px;
    border-bottom: 1px solid #e2e8f0;
    background: linear-gradient(135deg, #f8fafc 0%, #edf2f7 100%);
    border-radius: 12px 12px 0 0;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.settings-header h3 {
    margin: 0;
    color: #2c80ff;
    font-size: 18px;
    font-weight: 600;
}

.close-settings-btn {
    background: none;
    border: none;
    font-size: 20px;
    color: #718096;
    cursor: pointer;
    width: 32px;
    height: 32px;
    border-radius: 6px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s ease;
}

.close-settings-btn:hover {
    background: rgba(0, 0, 0, 0.05);
    color: #2c80ff;
}

.settings-body {
    flex: 1;
    padding: 20px;
    overflow-y: auto;
    max-height: 60vh;
}

.setting-group-modal {
    display: grid;
    grid-template-columns: 1fr;
    gap: 16px;
    margin: 0 0 20px 0;
}

.setting-item-modal {
    background: linear-gradient(135deg, #f8fafc 0%, #edf2f7 100%);
    padding: 16px;
    border-radius: 8px;
    border: 1px solid #e2e8f0;
}

.setting-item-modal label {
    display: block;
    margin-bottom: 8px;
    font-weight: 600;
    color: #4a5568;
    font-size: 14px;
}

.setting-item-modal input[type="range"] {
    width: 100%;
    margin: 8px 0;
}

.setting-value {
    display: block;
    font-size: 16px;
    font-weight: bold;
    color: #2c80ff;
    text-align: center;
    margin-top: 8px;
}

/* 控制按钮组 */
.control-buttons {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 8px;
    margin-top: 12px;
}

.control-buttons button {
    padding: 10px;
    font-size: 16px; /* 增大控制按钮字体 */
}

/* 设置按钮 */
.settings-btn {
    background: linear-gradient(135deg, #f6ad55 0%, #ed8936 100%);
    color: white;
    margin-top: 8px;
    font-size: 16px; /* 增大设置按钮字体 */
}

.settings-btn:hover {
    background: linear-gradient(135deg, #ed8936 0%, #dd6b20 100%);
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(237, 137, 54, 0.3);
}

/* 导出按钮 */
.export-btn {
    width: 100%;
    margin-top: 8px;
    padding: 10px;
    background: linear-gradient(135deg, #38a169 0%, #2f855a 100%);
    font-size: 16px; /* 增大导出按钮字体 */
}

.export-btn:hover {
    background: linear-gradient(135deg, #2f855a 0%, #276749 100%);
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(56, 161, 105, 0.3);
}

/* 新增：勾选导出按钮 */
.export-selected-btn {
    width: 100%;
    margin-top: 8px;
    padding: 10px;
    background: linear-gradient(135deg, #805ad5 0%, #6b46c1 100%);
    font-size: 16px;
}

.export-selected-btn:hover {
    background: linear-gradient(135deg, #6b46c1 0%, #553c9a 100%);
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(107, 70, 193, 0.3);
}

/* 新增：全选/取消全选按钮 */
.select-all-btn-compact {
    margin-top: 8px;
    padding: 8px 12px;
    background: linear-gradient(135deg, #edf2f7 0%, #e2e8f0 100%);
    color: #4a5568;
    border: 2px solid #e1e5eb;
    border-radius: 6px;
    cursor: pointer;
    font-weight: 500;
    transition: all 0.3s ease;
    font-size: 14px;
    flex: 1;
}

.select-all-btn-compact:hover {
    transform: translateY(-1px);
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
    border-color: #2c80ff;
    color: #2c80ff;
}

/* 状态信息 */
.status-info {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-top: 12px;
    padding-top: 12px;
    border-top: 1px solid #e2e8f0;
    font-size: 12px;
}

.source-count-display-compact {
    font-size: 13px;
    color: #2c80ff;
    font-weight: bold;
}

.selected-groups-info-compact {
    font-size: 11px;
    color: #718096;
}

.selected-groups-info-compact .count {
    color: #2c80ff;
    font-weight: bold;
}

/* 分组选择弹窗 */
.group-selector-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.5);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 2001;
    opacity: 0;
    visibility: hidden;
    transition: all 0.3s ease;
}

.group-selector-modal.show {
    opacity: 1;
    visibility: visible;
}

.group-selector-content {
    background: white;
    border-radius: 12px;
    width: 90%;
    max-width: 800px;
    max-height: 70vh;
    display: flex;
    flex-direction: column;
    box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
    transform: translateY(20px);
    transition: transform 0.3s ease;
}

.group-selector-modal.show .group-selector-content {
    transform: translateY(0);
}

.group-selector-header {
    padding: 16px;
    border-bottom: 1px solid #e2e8f0;
    background: linear-gradient(135deg, #f8fafc 0%, #edf2f7 100%);
    border-radius: 12px 12px 0 0;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.group-selector-header h3 {
    margin: 0;
    color: #2c80ff;
    font-size: 16px;
    font-weight: 600;
}

.close-modal-btn {
    background: none;
    border: none;
    font-size: 20px;
    color: #718096;
    cursor: pointer;
    width: 32px;
    height: 32px;
    border-radius: 6px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s ease;
}

.close-modal-btn:hover {
    background: rgba(0, 0, 0, 0.05);
    color: #2c80ff;
}

.group-selector-body {
    flex: 1;
    padding: 16px;
    overflow-y: auto;
    max-height: 50vh;
}

.groups-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
    gap: 12px;
    margin-bottom: 16px;
}

.group-item-modal {
    background: linear-gradient(135deg, #f8fafc 0%, #edf2f7 100%);
    border-radius: 8px;
    padding: 12px;
    border: 2px solid #e1e5eb;
    cursor: pointer;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    gap: 8px;
    position: relative;
    overflow: hidden;
}

.group-item-modal:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    border-color: #2c80ff;
}

.group-item-modal.selected {
    background: linear-gradient(135deg, #2c80ff 0%, #1a5bbf 100%);
    color: white;
    border-color: #2c80ff;
    box-shadow: 0 4px 12px rgba(44, 128, 255, 0.3);
}

.group-item-modal .group-checkbox {
    width: 16px;
    height: 16px;
    border: 2px solid #cbd5e0;
    border-radius: 4px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 12px;
    color: white;
    background: white;
    flex-shrink: 0;
}

.group-item-modal.selected .group-checkbox {
    background: white;
    color: #2c80ff;
    border-color: white;
}

.group-item-info {
    flex: 1;
    min-width: 0;
}

.group-item-modal .group-name {
    font-weight: 600;
    font-size: 14px;
    margin-bottom: 4px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.group-item-modal .group-count {
    font-size: 11px;
    color: #718096;
    background: rgba(255, 255, 255, 0.9);
    padding: 2px 6px;
    border-radius: 10px;
    display: inline-block;
}

.group-item-modal.selected .group-count {
    color: #2c80ff;
    background: rgba(255, 255, 255, 0.9);
}

.group-selector-footer {
    padding: 16px;
    border-top: 1px solid #e2e8f0;
    background: #f8fafc;
    display: flex;
    justify-content: space-between;
    align-items: center;
    border-radius: 0 0 12px 12px;
}

.group-summary {
    font-size: 13px;
    color: #4a5568;
}

.group-summary .count {
    color: #2c80ff;
    font-weight: bold;
}

.group-actions {
    display: flex;
    gap: 8px;
}

.group-action-btn {
    padding: 8px 16px;
    border-radius: 6px;
    font-size: 14px; /* 增大分组操作按钮字体 */
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
    border: 2px solid transparent;
}

.clear-all-btn {
    background: linear-gradient(135deg, #feb2b2 0%, #fc8181 100%);
    color: #c53030;
}

.clear-all-btn:hover {
    background: linear-gradient(135deg, #fc8181 0%, #f56565 100%);
    color: white;
    transform: translateY(-2px);
    box-shadow: 0 2px 8px rgba(252, 129, 129, 0.3);
}

.select-all-btn {
    background: linear-gradient(135deg, #9ae6b4 0%, #68d391 100%);
    color: #276749;
}

.select-all-btn:hover {
    background: linear-gradient(135deg, #68d391 0%, #48bb78 100%);
    color: white;
    transform: translateY(-2px);
    box-shadow: 0 2px 8px rgba(104, 211, 145, 0.3);
}

/* 并发状态 */
.concurrency-status { 
    font-size: 11px; 
    color: #666; 
    margin-top: 8px; 
    text-align: center; 
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 8px;
}
.concurrency-value { 
    color: #2c80ff; 
    font-weight: bold;
    display: block;
    margin-top: 2px;
}
        
/* 当前播放信息 */
.current-playing-info {
    font-size: 12px;
    color: #666;
    margin-bottom: 8px;
    padding: 6px;
    background: #f8fafc;
    border-radius: 6px;
    border-left: 3px solid #2c80ff;
}

/* 新增：复选框样式 */
.source-checkbox {
    width: 18px;
    height: 18px;
    margin-right: 12px;
    flex-shrink: 0;
    cursor: pointer;
    accent-color: #2c80ff;
}

.source-checkbox:checked {
    background-color: #2c80ff;
}

/* 勾选统计信息 */
.selection-stats {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-top: 12px;
    padding-top: 12px;
    border-top: 1px solid #e2e8f0;
    font-size: 12px;
    color: #718096;
}

.selection-stats .selected-count {
    color: #2c80ff;
    font-weight: bold;
}

/* 滚动条美化 */
::-webkit-scrollbar {
    width: 6px;
    height: 6px;
}

::-webkit-scrollbar-track {
    background: #f1f5f9;
    border-radius: 3px;
}

::-webkit-scrollbar-thumb {
    background: linear-gradient(135deg, #a0aec0 0%, #718096 100%);
    border-radius: 3px;
}

::-webkit-scrollbar-thumb:hover {
    background: linear-gradient(135deg, #718096 0%, #4a5568 100%);
}

/* 响应式优化 */
@media (max-width: 1200px) {
    .top-section {
        grid-template-columns: 1fr;
    }
    
    .video-player-container video {
        max-height: 50vh; /* 响应式高度调整 */
    }
}

@media (max-width: 768px) {
    body {
        padding: 8px;
    }
    
    .card {
        padding: 12px;
    }
    
    .compact-import-container {
        grid-template-columns: 1fr;
        gap: 8px;
    }
    
    .stats {
        grid-template-columns: repeat(2, 1fr);
    }
    
    .group-selector-content,
    .settings-content {
        width: 95%;
        max-height: 80vh;
    }
    
    .groups-grid {
        grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
    }
    
    .version-badge {
        position: relative;
        top: 0;
        right: 0;
        margin-bottom: 12px;
        display: inline-block;
    }
    
    /* 移动端按钮字体适当减小 */
    button {
        font-size: 14px;
    }
    
    .control-buttons button,
    .settings-btn,
    .export-btn,
    .player-controls button {
        font-size: 14px;
    }
    
    /* 视频弹窗移动端优化 */
    .video-modal {
        width: 98%;
        max-width: 100%;
        max-height: 60vh;
        top: 10px;
    }
    
    .video-modal-body {
        padding: 12px;
    }
    
    .video-modal-header {
        padding: 10px 12px;
    }
    
    .video-player-container {
        min-height: 180px;
    }
}

@media (max-width: 480px) {
    .file-import-row,
    .url-import-row {
        flex-direction: column;
    }
    
    .control-buttons {
        grid-template-columns: 1fr;
    }
    
    .groups-grid {
        grid-template-columns: 1fr;
    }
    
    .group-action-btn {
        flex: 1;
        padding: 10px;
    }
    
    /* 视频弹窗移动端优化 */
    .video-modal {
        max-height: 50vh;
        top: 5px;
    }
    
    .video-player-container {
        min-height: 150px;
    }
}

/* 原有的其他样式（未修改的部分） */
.check-time { 
    font-size: 10px; 
    color: #666;
    background: #f0f0f0;
    padding: 2px 4px;
    border-radius: 3px;
    margin-right: 4px;
    font-family: monospace;
}
.check-time.success { background: #e8f5e9; color: #2e7d32; }
.check-time.failed { background: #ffebee; color: #c62828; }
.check-time.pending { background: #e3f2fd; color: #1565c0; }
.right-section { 
    display: flex; 
    align-items: center; 
    gap: 8px; 
    flex-shrink: 0;
}
.example-links { margin-top: 4px; font-size: 11px; color: #666; }
.example-link { color: #2c80ff; cursor: pointer; text-decoration: underline; margin: 0 4px; }
.example-link:hover { color: #1a5bbf; }
.loading-indicator { display: none; text-align: center; padding: 8px; color: #2c80ff; font-size: 12px; }
    </style>
</head>
<body>
    <div class="version-badge">v1.4.1</div>
    
    <!-- 视频播放弹窗 - 悬浮模式 -->
    <div class="video-modal" id="videoModal">
        <div class="video-modal-header">
            <div class="video-modal-title">
                <span>视频预览</span>
                <div class="video-modal-status idle" id="videoModalStatus">未播放</div>
            </div>
            <button class="close-video-modal" id="closeVideoModalBtn">×</button>
        </div>
        <div class="video-modal-body">
            <div class="video-player-container">
                <video id="videoPlayer" controls></video>
            </div>
            <div class="video-info" id="videoModalInfo">未选择频道</div>
            <div class="video-controls">
                <button id="videoStopBtn" class="video-stop-btn" disabled>停止播放</button>
            </div>
        </div>
    </div>
    
    <div class="container">
        <!-- 顶部区域 -->
        <div class="top-section">
            <!-- 头部区域 -->
            <div class="card header-card">
                <div class="compact-header">
                    <h2>直播源检测</h2>
                    <div class="selected-groups-info-compact" id="selectedGroupsInfo">
                        已选择 <span class="count">0</span> 个分组，共 <span class="count">0</span> 个频道
                    </div>
                </div>
                
                <div class="compact-import-container">
                    <div class="import-section-compact">
                        <div class="import-section-title">导入直播源</div>
                        
                        <div class="file-import-row">
                            <input type="file" id="fileInput" accept=".txt,.m3u" title="选择本地直播源文件">
                            <button id="fileImportBtn">导入文件</button>
                        </div>
                        
                        <div class="url-import-row">
                            <input type="text" id="urlInput" placeholder="输入URL地址" value="">
                            <button id="urlImportBtn">导入URL</button>
                        </div>
                        
                        <div class="example-links">
                            示例：
                            <span class="example-link" data-example="gitee">Gitee</span> | 
                            <span class="example-link" data-example="direct">直接URL</span>
                        </div>
                        <div class="loading-indicator" id="loadingIndicator">正在加载...</div>
                    </div>
                    
                    <div class="import-section-compact" style="display: none;" id="groupImportSection">
                        <div class="import-section-title">分组选择</div>
                        <button class="group-selector-btn" id="groupSelectorBtn">
                            <span class="group-selector-text" id="groupSelectorText">选择检测分组...</span>
                            <span class="group-selector-arrow">▼</span>
                        </button>
                        <div class="selected-groups-info-compact" id="groupDropdownSummary">
                            已选择 <span class="count">0</span> 个分组，共 <span class="count">0</span> 个频道
                        </div>
                    </div>
                </div>
                
                <div class="status-info">
                    <div class="source-count-display-compact" id="sourceCount">0个频道</div>
                    <div id="groupCountHint" style="font-size: 11px; color: #888; font-style: italic;">
                        点击分组选择按钮选择要检测的分组
                    </div>
                </div>
            </div>
        </div>

        <!-- 中部区域 - 控制区域占满整行 -->
        <div class="top-section">
            <!-- 控制区域 - 简化 -->
            <div class="card controls-card">
                <h2>检测控制</h2>
                
                <div class="concurrency-status">
                    <div>当前并发: <span class="concurrency-value" id="currentConcurrency">5</span></div>
                    <div>运行中: <span class="concurrency-value" id="activeTasks">0</span></div>
                    <div>队列: <span class="concurrency-value" id="queueSize">0</span></div>
                </div>
                
                <div class="queue-status" id="queueStatus" style="display: none;">
                    <div>并发队列:</div>
                    <div id="queueDisplay"></div>
                </div>
                
                <div class="progress">
                    <div class="progress-bar" id="progressBar"></div>
                </div>
                <div id="progressText" style="font-size: 12px; text-align: center; margin: 4px 0;">等待开始</div>
                
                <div class="control-buttons">
                    <button id="start">开始检测</button>
                    <button id="pause" disabled>暂停检测</button>
                </div>
                
                <button id="settingsBtn" class="settings-btn">检测设置</button>
                <button id="exportOnline" class="export-btn">智能导出(仅在线)</button>
                <!-- 新增：勾选导出按钮 -->
                <button id="exportSelected" class="export-selected-btn" disabled>导出勾选频道</button>
            </div>
        </div>

        <!-- 底部区域 - 列表填满 -->
        <div class="bottom-section">
            <!-- 列表区域 -->
            <div class="card list-card">
                <div class="source-list-container">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                        <h2>直播源列表</h2>
                        <div class="filter-buttons">
                            <button class="filter-btn active" data-filter="all">全部</button>
                            <button class="filter-btn" data-filter="online">在线</button>
                            <button class="filter-btn" data-filter="offline">离线</button>
                            <!-- 新增：全选/取消全选按钮 -->
                            <button class="select-all-btn-compact" id="selectAllBtn">全选当前列表</button>
                        </div>
                    </div>
                    
                    <div class="source-list" id="sourceList">
                        <div style="text-align: center; padding: 20px; color: #999;">暂无直播源</div>
                    </div>
                    
                    <!-- 新增：勾选统计信息 -->
                    <div class="selection-stats" id="selectionStats" style="display: none;">
                        <div>已勾选: <span class="selected-count" id="selectedCount">0</span> 个频道</div>
                        <div>点击上方"全选当前列表"可快速选择</div>
                    </div>
                    
                    <div class="stats">
                        <div class="stat"><div class="stat-value" id="total">0</div><div class="stat-label">总数</div></div>
                        <div class="stat"><div class="stat-value" id="success">0</div><div class="stat-label">有效</div></div>
                        <div class="stat"><div class="stat-value" id="failed">0</div><div class="stat-label">无效</div></div>
                        <div class="stat"><div class="stat-value" id="pending">0</div><div class="stat-label">待检测</div></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- 检测设置弹窗 -->
    <div class="settings-modal" id="settingsModal">
        <div class="settings-content">
            <div class="settings-header">
                <h3>检测设置</h3>
                <button class="close-settings-btn" id="closeSettingsBtn">×</button>
            </div>
            <div class="settings-body">
                <div class="setting-group-modal">
                    <div class="setting-item-modal">
                        <label>检测时长(秒): <span class="setting-value" id="timeoutValue">5</span></label>
                        <input type="range" id="timeoutSlider" min="1" max="30" value="5">
                        <div style="display: flex; justify-content: space-between; font-size: 11px; color: #718096;">
                            <span>1秒</span>
                            <span>30秒</span>
                        </div>
                    </div>
                    
                    <div class="setting-item-modal">
                        <label>延迟时间(毫秒): <span class="setting-value" id="delayValue">100</span></label>
                        <input type="range" id="delaySlider" min="0" max="1000" value="100" step="50">
                        <div style="display: flex; justify-content: space-between; font-size: 11px; color: #718096;">
                            <span>0毫秒</span>
                            <span>1000毫秒</span>
                        </div>
                    </div>
                    
                    <div class="setting-item-modal">
                        <label>并发数: <span class="setting-value" id="concurrencyValue">5</span></label>
                        <input type="range" id="concurrencySlider" min="1" max="50" value="5">
                        <div style="display: flex; justify-content: space-between; font-size: 11px; color: #718096;">
                            <span>1个</span>
                            <span>50个</span>
                        </div>
                    </div>
                </div>
                
                <div style="text-align: center; margin-top: 20px;">
                    <button id="saveSettings" style="padding: 12px 24px; font-size: 14px;">保存设置</button>
                </div>
            </div>
        </div>
    </div>

    <!-- 分组选择弹窗 -->
    <div class="group-selector-modal" id="groupSelectorModal">
        <div class="group-selector-content">
            <div class="group-selector-header">
                <h3>选择检测分组</h3>
                <button class="close-modal-btn" id="closeModalBtn">×</button>
            </div>
            <div class="group-selector-body">
                <div class="groups-grid" id="groupsGrid">
                    <!-- 分组列表将通过JavaScript动态生成 -->
                    <div style="text-align: center; padding: 40px; color: #999; grid-column: 1 / -1;">
                        暂无分组，请先导入直播源
                    </div>
                </div>
            </div>
            <div class="group-selector-footer">
                <div class="group-summary" id="groupModalSummary">
                    已选择 <span class="count">0</span> 个分组，共 <span class="count">0</span> 个频道
                </div>
                <div class="group-actions">
                    <button class="group-action-btn clear-all-btn" id="modalClearAllBtn">全不选</button>
                    <button class="group-action-btn select-all-btn" id="modalSelectAllBtn">全选</button>
                </div>
            </div>
        </div>
    </div>

    <div class="notification" id="notification"></div>

<script>
// ==================== 性能优化开始 ====================

// 版本常量
const VERSION = '1.4.1';

// 性能监控器
const perfMonitor = {
    operations: 0,
    domUpdates: 0,
    startTime: 0,
    
    start: function() {
        this.startTime = performance.now();
        this.operations = 0;
        this.domUpdates = 0;
    },
    
    logOperation: function() {
        this.operations++;
    },
    
    logDOMUpdate: function() {
        this.domUpdates++;
    },
    
    getStats: function() {
        const duration = performance.now() - this.startTime;
        return {
            duration: duration.toFixed(2),
            operations: this.operations,
            domUpdates: this.domUpdates,
            opsPerSecond: ((this.operations / duration) * 1000).toFixed(2)
        };
    }
};

// 批量DOM更新队列
const domUpdateQueue = {
    queue: [],
    timeoutId: null,
    BATCH_INTERVAL: 16, // ~60fps
    
    enqueue: function(callback) {
        this.queue.push(callback);
        perfMonitor.logDOMUpdate();
        
        if (!this.timeoutId) {
            this.timeoutId = setTimeout(() => {
                this.flush();
            }, this.BATCH_INTERVAL);
        }
    },
    
    flush: function() {
        if (this.timeoutId) {
            clearTimeout(this.timeoutId);
            this.timeoutId = null;
        }
        
        if (this.queue.length > 0) {
            const queueCopy = [...this.queue];
            this.queue.length = 0;
            
            requestAnimationFrame(() => {
                queueCopy.forEach(callback => callback());
            });
        }
    }
};

// 优化的事件委托管理器
const eventDelegate = {
    handlers: new Map(),
    
    add: function(container, selector, eventType, handler) {
        const key = `${selector}_${eventType}`;
        if (!this.handlers.has(key)) {
            this.handlers.set(key, handler);
            container.addEventListener(eventType, (e) => {
                const target = e.target.closest(selector);
                if (target && container.contains(target)) {
                    handler(e, target);
                }
            });
        }
    }
};

// 缓存DOM查询结果
const domCache = {
    elements: new Map(),
    
    get: function(id) {
        if (!this.elements.has(id)) {
            this.elements.set(id, document.getElementById(id));
        }
        return this.elements.get(id);
    },
    
    clear: function() {
        this.elements.clear();
    }
};

// ==================== 状态管理 ====================

const state = {
    sources: [],
    testing: false,
    paused: false,
    startTime: 0,
    completed: 0,
    valid: [],
    abortController: null,
    currentFilter: 'all',
    delayTime: 100,
    concurrency: 5, // 修改：从30改为5
    activeTasks: 0,
    taskQueue: [],
    nextIndex: 0,
    startInterval: 500,
    startTimer: null,
    groups: [],
    selectedGroups: new Set(),
    allGroupsSelected: true,
    currentPlayingIndex: -1,
    isPlaying: false,
    loadTimeout: null,
    videoListeners: {},
    originalContent: '',
    groupInfoMap: new Map(),
    
    // 新增：勾选状态 - 修复：使用对象存储，键是源ID
    selectedSources: {}, // 对象，键是源ID，值是布尔值（是否被选中）
    
    // 添加索引以提高查找速度
    sourceById: new Map(),
    sourcesByGroup: new Map(),
    
    // 添加缓存
    filteredSourcesCache: null,
    selectedSourcesCache: null,
    lastFilter: 'all',
    lastSelectionHash: ''
};

// 状态更新方法
state.updateSource = function(source) {
    const index = this.sources.findIndex(s => s.id === source.id);
    if (index !== -1) {
        this.sources[index] = source;
        this.sourceById.set(source.id, source);
        
        // 清除缓存
        this.filteredSourcesCache = null;
        this.selectedSourcesCache = null;
        
        return true;
    }
    return false;
};

// 获取选中源的方法
state.getSelectedSourcesCount = function() {
    perfMonitor.logOperation();
    return this.getSelectedSources().length;
};

state.getSelectedSources = function() {
    perfMonitor.logOperation();
    
    // 检查缓存
    const currentHash = `${this.selectedGroups.size}_${this.allGroupsSelected}`;
    if (this.selectedSourcesCache && this.lastSelectionHash === currentHash) {
        return this.selectedSourcesCache;
    }
    
    let result;
    if (this.allGroupsSelected || !this.selectedGroups.size) {
        result = this.sources;
    } else {
        // 使用缓存的分组映射
        if (!this.sourcesByGroup.size) {
            this.buildGroupIndex();
        }
        
        result = [];
        this.selectedGroups.forEach(groupName => {
            const groupSources = this.sourcesByGroup.get(groupName);
            if (groupSources) {
                result.push(...groupSources);
            }
        });
    }
    
    // 更新缓存
    this.selectedSourcesCache = result;
    this.lastSelectionHash = currentHash;
    
    return result;
};

// 构建分组索引
state.buildGroupIndex = function() {
    this.sourcesByGroup.clear();
    this.sources.forEach(source => {
        const group = source.group || '未分组';
        if (!this.sourcesByGroup.has(group)) {
            this.sourcesByGroup.set(group, []);
        }
        this.sourcesByGroup.get(group).push(source);
    });
};

// 新增：获取当前筛选后的源
state.getFilteredSources = function() {
    perfMonitor.logOperation();
    
    const selectedSources = this.getSelectedSources();
    let filteredSources = selectedSources;
    
    if (this.currentFilter === 'online') {
        filteredSources = selectedSources.filter(s => s.status === 'success');
    } else if (this.currentFilter === 'offline') {
        filteredSources = selectedSources.filter(s => s.status === 'failed');
    }
    
    return filteredSources;
};

// 新增：获取勾选源的数量 - 修复：从对象中获取
state.getSelectedCount = function() {
    return Object.values(this.selectedSources).filter(selected => selected === true).length;
};

// 新增：切换源的勾选状态 - 修复：改为对象操作
state.toggleSourceSelection = function(sourceId) {
    if (this.selectedSources[sourceId]) {
        delete this.selectedSources[sourceId];
    } else {
        this.selectedSources[sourceId] = true;
    }
    console.log('切换勾选状态:', sourceId, '当前选中:', this.selectedSources[sourceId], '选中总数:', this.getSelectedCount());
};

// 新增：检查源是否被勾选 - 修复：从对象中检查
state.isSourceSelected = function(sourceId) {
    return !!this.selectedSources[sourceId];
};

// 新增：全选/取消全选当前列表 - 修复：改为对象操作
state.toggleSelectAll = function() {
    const filteredSources = this.getFilteredSources();
    
    // 如果已经全部选中，则取消全选
    const allSelected = filteredSources.every(source => this.selectedSources[source.id]);
    
    if (allSelected) {
        filteredSources.forEach(source => {
            delete this.selectedSources[source.id];
        });
    } else {
        filteredSources.forEach(source => {
            this.selectedSources[source.id] = true;
        });
    }
    
    return !allSelected; // 返回新的选择状态
};

// 新增：清空所有勾选 - 修复：清空对象
state.clearAllSelections = function() {
    this.selectedSources = {};
};

// 新增：获取所有被勾选的源对象 - 修复：从对象中获取
state.getSelectedSourceObjects = function() {
    const selectedSources = [];
    this.sources.forEach(source => {
        if (this.selectedSources[source.id]) {
            selectedSources.push(source);
        }
    });
    return selectedSources;
};

// ==================== 工具函数 ====================

const utils = {
    cleanBrackets: (text) => {
        if (!text) return text;
        const bracketRegex = /^[（(【[{](.*?)[）)】]}]$/;
        const match = text.match(bracketRegex);
        return match ? match[1].trim() : text.trim();
    },
    
    getNameFromUrl: (url) => {
        try {
            const urlObj = new URL(url);
            const domain = urlObj.hostname.replace('www.', '').split('.')[0];
            return domain.charAt(0).toUpperCase() + domain.slice(1) + '频道';
        } catch {
            return '未命名频道';
        }
    },
    
    isValidUrl: (url) => {
        try {
            new URL(url);
            return true;
        } catch {
            return false;
        }
    },
    
    showMsg: (text, type = 'success') => {
        const notif = domCache.get('notification');
        notif.textContent = text;
        notif.style.background = type === 'error' ? '#f44336' : '#4CAF50';
        notif.style.display = 'block';
        notif.style.opacity = '1';
        notif.style.transform = 'translateX(0)';
        
        setTimeout(() => {
            notif.style.opacity = '0';
            notif.style.transform = 'translateX(20px)';
            setTimeout(() => {
                notif.style.display = 'none';
                notif.style.opacity = '1';
                notif.style.transform = 'translateX(0)';
            }, 300);
        }, 2700);
    },
    
    fetchUrlContent: async (url) => {
        try {
            const response = await fetch(url, {
                method: 'GET',
                mode: 'cors',
                headers: {
                    'Accept': 'text/plain,application/x-mpegURL,text/html',
                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
                }
            });
            
            if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            return await response.text();
        } catch (error) {
            try {
                const proxyUrl = 'https://api.allorigins.win/raw?url=' + encodeURIComponent(url);
                const response = await fetch(proxyUrl);
                if (response.ok) return await response.text();
                throw new Error('代理获取失败');
            } catch {
                throw new Error('无法获取内容: ' + error.message);
            }
        }
    },
    
    // 添加防抖函数
    debounce: function(func, wait) {
        let timeout;
        return function executedFunction(...args) {
            const later = () => {
                clearTimeout(timeout);
                func(...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    },
    
    // 添加节流函数
    throttle: function(func, limit) {
        let inThrottle;
        return function executedFunction(...args) {
            if (!inThrottle) {
                func(...args);
                inThrottle = true;
                setTimeout(() => inThrottle = false, limit);
            }
        };
    }
};

// ==================== 解析逻辑 ====================

const parser = {
    parseContent: function(content) {
        perfMonitor.start();
        
        state.sources = [];
        state.sourceById.clear();
        state.sourcesByGroup.clear();
        state.originalContent = content;
        state.filteredSourcesCache = null;
        state.selectedSourcesCache = null;
        state.selectedSources = {}; // 修复：清空勾选状态，改为对象
        
        const lines = content.split('\n');
        const sourceMap = new Map();
        
        state.groupInfoMap.clear();
        
        // 使用正则表达式预编译提高性能
        const groupTitleRegex = /group-title="([^"]*)"/;
        const tvgNameRegex = /tvg-name="([^"]*)"/;
        const urlRegex = /^(http|https|rtp|rtsp|udp):\/\/|\.(m3u8|ts)$/;
        
        let currentExtInf = null;
        let currentName = '';
        let currentGroup = '';
        let simpleCurrentGroup = '默认分组';
        let currentGroupInfo = { name: simpleCurrentGroup, type: 'genre', originalLine: '' };
        
        const createSource = (finalUrl, finalName, finalGroup, finalExtInf, lineIndex, originalLineContent) => {
            const key = `${finalUrl}_${finalName}`;
            if (!sourceMap.has(key)) {
                const source = {
                    id: (Date.now() + Math.random()).toString(), // 确保ID是字符串
                    name: finalName || utils.getNameFromUrl(finalUrl),
                    url: finalUrl,
                    status: 'pending',
                    testing: false,
                    checkTime: null,
                    startTime: null,
                    group: finalGroup,
                    extinf: finalExtInf,
                    originalLine: lineIndex,
                    originalContent: originalLineContent,
                    groupType: currentGroupInfo.type,
                    selected: false // 新增：默认未勾选
                };
                state.sources.push(source);
                sourceMap.set(key, source);
                state.sourceById.set(source.id, source);
            }
        };
        
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i].trim();
            if (!line) continue;
            
            if (line === '#EXTM3U') continue;
            
            if (line.startsWith('#EXTINF:')) {
                currentExtInf = line;
                currentName = '';
                currentGroup = '';
                
                const groupMatch = line.match(groupTitleRegex);
                if (groupMatch?.[1]) {
                    currentGroup = groupMatch[1].trim();
                    currentGroupInfo = { name: currentGroup, type: 'grouptitle', originalLine: '' };
                    if (!state.groupInfoMap.has(currentGroup)) {
                        state.groupInfoMap.set(currentGroup, currentGroupInfo);
                    }
                }
                
                const tvgNameMatch = line.match(tvgNameRegex);
                if (tvgNameMatch?.[1]) {
                    currentName = tvgNameMatch[1].trim();
                } else {
                    const lastCommaIndex = line.lastIndexOf(',');
                    currentName = lastCommaIndex !== -1 ? line.substring(lastCommaIndex + 1).trim() : '未命名频道';
                }
                
                currentName = utils.cleanBrackets(currentName);
                continue;
            }
            
            if (line.includes('#genre#')) {
                const commaIndex = line.indexOf(',');
                simpleCurrentGroup = commaIndex !== -1 ? line.substring(0, commaIndex).trim() : '未命名分组';
                if (!simpleCurrentGroup) simpleCurrentGroup = '未命名分组';
                
                currentGroupInfo = { name: simpleCurrentGroup, type: 'genre', originalLine: line };
                if (!state.groupInfoMap.has(simpleCurrentGroup)) {
                    state.groupInfoMap.set(simpleCurrentGroup, currentGroupInfo);
                }
                continue;
            }
            
            const isStreamUrl = line.includes('://') || line.includes('.m3u8') || line.includes('.ts') || 
                               line.startsWith('udp://') || line.startsWith('rtp://');
            
            if (isStreamUrl) {
                let finalUrl = line;
                let finalName = currentName || '未命名频道';
                let finalGroup = currentGroup || simpleCurrentGroup || '默认分组';
                let originalLineContent = line;
                
                if (currentExtInf) {
                    originalLineContent = `${currentExtInf}\n${line}`;
                } else {
                    const commaIndex = line.indexOf(',');
                    if (commaIndex !== -1) {
                        const namePart = line.substring(0, commaIndex).trim();
                        finalUrl = line.substring(commaIndex + 1).trim();
                        
                        if (finalUrl?.match(urlRegex)) {
                            finalName = utils.cleanBrackets(namePart) || finalName;
                        } else {
                            continue;
                        }
                    }
                }
                
                if (finalUrl?.match(urlRegex)) {
                    createSource(finalUrl, finalName, finalGroup, currentExtInf, i, originalLineContent);
                    currentExtInf = null;
                    currentName = '';
                    currentGroup = '';
                }
                continue;
            }
            
            if (!line.startsWith('#')) {
                currentName = utils.cleanBrackets(line);
            }
        }
        
        // 构建分组索引
        state.buildGroupIndex();
        
        domCache.get('sourceCount').textContent = state.sources.length + '个频道';
        ui.updateGroups();
        ui.updateStats();
        ui.updateExportButton();
        ui.updateSelectionStats(); // 新增：更新勾选统计
        
        // 关键修复：强制立即更新列表，不通过队列延迟
        ui.updateSourceList(true);
        
        console.log('解析完成，性能统计:', perfMonitor.getStats());
    }
};

// ==================== UI 更新函数 ====================

const ui = {
    updateGroups: function() {
        const groupMap = new Map();
        state.sources.forEach(source => {
            const groupName = source.group || '未分组';
            if (!groupMap.has(groupName)) {
                groupMap.set(groupName, { name: groupName, count: 0, selected: true });
            }
            groupMap.get(groupName).count++;
        });
        
        state.groups = Array.from(groupMap.values())
            .sort((a, b) => a.name.localeCompare(b.name, 'zh-CN'));
        
        this.refreshGroupSelector();
        this.refreshGroupModal();
        this.updateSelectedGroupsInfo();
    },
    
    refreshGroupSelector: function() {
        const groupSection = domCache.get('groupImportSection');
        const selectorBtn = domCache.get('groupSelectorBtn');
        const selectorText = domCache.get('groupSelectorText');
        
        if (!state.groups.length) {
            groupSection.style.display = 'none';
            domCache.get('groupCountHint').textContent = '导入直播源后显示分组选择';
            return;
        }
        
        groupSection.style.display = 'block';
        
        const selectedCount = state.groups.filter(g => g.selected).length;
        selectorText.textContent = !selectedCount ? '选择检测分组...' : 
                                   selectedCount === state.groups.length ? '所有分组' : 
                                   selectedCount === 1 ? state.groups.find(g => g.selected)?.name : 
                                   `${selectedCount}个分组`;
        
        this.updateSelectedGroupsInfo();
        
        if (state.groups.length) {
            domCache.get('groupCountHint').textContent = `共${state.groups.length}个分组，点击按钮选择`;
        }
    },
    
    refreshGroupModal: function() {
        const groupsGrid = domCache.get('groupsGrid');
        if (!state.groups.length) {
            groupsGrid.innerHTML = '<div style="text-align: center; padding: 40px; color: #999; grid-column: 1 / -1;">暂无分组，请先导入直播源</div>';
            return;
        }
        
        groupsGrid.innerHTML = '';
        
        state.groups.forEach(group => {
            const groupItem = document.createElement('div');
            groupItem.className = `group-item-modal${group.selected ? ' selected' : ''}`;
            groupItem.innerHTML = `
                <div class="group-checkbox">${group.selected ? '✓' : ''}</div>
                <div class="group-item-info">
                    <div class="group-name" title="${group.name}">${group.name}</div>
                    <div class="group-count">${group.count}个频道</div>
                </div>
            `;
            groupItem.addEventListener('click', () => handlers.handleGroupToggle(null, group.name));
            groupsGrid.appendChild(groupItem);
        });
        
        this.updateModalSummary();
    },
    
    updateSelectedGroupsInfo: function() {
        const selectedGroupsCount = state.groups.filter(g => g.selected).length;
        const selectedSourcesCount = state.getSelectedSourcesCount();
        
        const infoHTML = `已选择 <span class="count">${selectedGroupsCount}</span> 个分组，共 <span class="count">${selectedSourcesCount}</span> 个频道`;
        
        domCache.get('selectedGroupsInfo').innerHTML = infoHTML;
        domCache.get('groupDropdownSummary').innerHTML = infoHTML;
    },
    
    updateModalSummary: function() {
        const selectedGroupsCount = state.groups.filter(g => g.selected).length;
        const selectedSourcesCount = state.getSelectedSourcesCount();
        
        domCache.get('groupModalSummary').innerHTML = `已选择 <span class="count">${selectedGroupsCount}</span> 个分组，共 <span class="count">${selectedSourcesCount}</span> 个频道`;
    },
    
    updateStats: utils.throttle(function() {
        perfMonitor.logOperation();
        
        domUpdateQueue.enqueue(() => {
            const selectedSources = state.getSelectedSources();
            const totalSelected = selectedSources.length;
            const successCount = selectedSources.filter(s => s.status === 'success').length;
            const failedCount = selectedSources.filter(s => s.status === 'failed').length;
            const pendingCount = totalSelected - successCount - failedCount;
            
            const updateIfChanged = (elementId, value) => {
                const element = domCache.get(elementId);
                if (element && element.textContent !== value.toString()) {
                    element.textContent = value;
                }
            };
            
            updateIfChanged('total', totalSelected);
            updateIfChanged('success', successCount);
            updateIfChanged('failed', failedCount);
            updateIfChanged('pending', pendingCount);
            
            this.updateExportButton();
        });
    }, 100),
    
    updateProgress: utils.throttle(function() {
        perfMonitor.logOperation();
        
        domUpdateQueue.enqueue(() => {
            const selectedSourcesCount = state.getSelectedSourcesCount();
            const percent = selectedSourcesCount ? Math.round((state.completed / selectedSourcesCount) * 100) : 0;
            
            const progressBar = domCache.get('progressBar');
            const progressText = domCache.get('progressText');
            
            if (progressBar) {
                progressBar.style.width = percent + '%';
            }
            if (progressText) {
                progressText.textContent = `检测进度: ${state.completed}/${selectedSourcesCount} (${percent}%)`;
            }
        });
    }, 100),
    
    updateConcurrencyStatus: utils.throttle(function() {
        domUpdateQueue.enqueue(() => {
            const activeTasksEl = domCache.get('activeTasks');
            const queueSizeEl = domCache.get('queueSize');
            const queueStatusEl = domCache.get('queueStatus');
            const currentConcurrencyEl = domCache.get('currentConcurrency');
            
            if (activeTasksEl) activeTasksEl.textContent = state.activeTasks;
            if (queueSizeEl) queueSizeEl.textContent = state.taskQueue.length;
            if (currentConcurrencyEl) currentConcurrencyEl.textContent = state.concurrency;
            if (queueStatusEl) {
                queueStatusEl.style.display = (state.taskQueue.length || state.activeTasks) ? 'block' : 'none';
            }
        });
    }, 50),
    
    updateQueueDisplay: utils.throttle(function() {
        perfMonitor.logOperation();
        
        domUpdateQueue.enqueue(() => {
            const queueDisplay = domCache.get('queueDisplay');
            if (!queueDisplay) return;
            
            const selectedSources = state.getSelectedSources();
            const displayCount = Math.min(10, selectedSources.length);
            
            let html = '';
            for (let i = 0; i < displayCount; i++) {
                const source = selectedSources[i];
                let className = 'queue-item';
                let content = i + 1;
                
                if (i < state.nextIndex) {
                    if (source.status === 'success') {
                        className += ' success';
                        content = '✓';
                    } else if (source.status === 'failed') {
                        className += ' failed';
                        content = '✗';
                    } else if (source.testing) {
                        className += ' active';
                        content = i + 1;
                    }
                }
                
                html += `<span class="${className}" title="第${i + 1}个: ${source.name} (分组: ${source.group})">${content}</span>`;
            }
            
            if (selectedSources.length > 10) {
                html += `<span class="queue-item" title="还有${selectedSources.length - 10}个">...</span>`;
            }
            
            queueDisplay.innerHTML = html;
        });
    }, 100),
    
    updateExportButton: function() {
        domUpdateQueue.enqueue(() => {
            const exportBtn = domCache.get('exportOnline');
            exportBtn.disabled = !state.sources.some(s => s.status === 'success');
            
            // 新增：更新勾选导出按钮状态 - 修复：只要有勾选就启用
            const exportSelectedBtn = domCache.get('exportSelected');
            exportSelectedBtn.disabled = state.getSelectedCount() === 0;
        });
    },
    
    // 新增：更新勾选统计信息
    updateSelectionStats: function() {
        domUpdateQueue.enqueue(() => {
            const selectedCount = state.getSelectedCount();
            const selectionStats = domCache.get('selectionStats');
            const selectedCountEl = domCache.get('selectedCount');
            const selectAllBtn = domCache.get('selectAllBtn');
            
            if (selectedCountEl) selectedCountEl.textContent = selectedCount;
            
            if (selectionStats) {
                selectionStats.style.display = selectedCount > 0 ? 'flex' : 'none';
            }
            
            if (selectAllBtn) {
                const filteredSources = state.getFilteredSources();
                const allSelected = filteredSources.length > 0 && 
                                  filteredSources.every(source => state.isSourceSelected(source.id));
                selectAllBtn.textContent = allSelected ? '取消全选' : '全选当前列表';
            }
            
            // 更新导出按钮状态
            this.updateExportButton();
        });
    },
    
    updateSourceList: function(forceUpdate = false) {
        perfMonitor.logOperation();
        
        const container = domCache.get('sourceList');
        if (!container) return;
        
        // 使用立即执行，不放入队列，确保列表立即显示
        const updateFunction = () => {
            const selectedSources = state.getSelectedSources();
            let filteredSources = selectedSources;
            
            // 检查缓存
            if (!forceUpdate && 
                state.filteredSourcesCache && 
                state.lastFilter === state.currentFilter &&
                state.filteredSourcesCache.length === filteredSources.length) {
                return;
            }
            
            if (state.currentFilter === 'online') {
                filteredSources = selectedSources.filter(s => s.status === 'success');
            } else if (state.currentFilter === 'offline') {
                filteredSources = selectedSources.filter(s => s.status === 'failed');
            }
            
            state.filteredSourcesCache = filteredSources;
            state.lastFilter = state.currentFilter;
            
            // 使用DocumentFragment减少回流
            const fragment = document.createDocumentFragment();
            
            if (!filteredSources.length) {
                const messages = {
                    all: '暂无直播源',
                    online: '暂无在线源',
                    offline: '暂无离线源'
                };
                const emptyMsg = document.createElement('div');
                emptyMsg.style.cssText = 'text-align: center; padding: 20px; color: #999;';
                emptyMsg.textContent = messages[state.currentFilter] || messages.all;
                fragment.appendChild(emptyMsg);
            } else {
                // 重用现有DOM元素
                const existingItems = container.querySelectorAll('.source-item');
                const existingItemsMap = new Map();
                
                existingItems.forEach(item => {
                    const sourceId = item.getAttribute('data-id');
                    if (sourceId) existingItemsMap.set(sourceId, item);
                });
                
                filteredSources.forEach(source => {
                    let item = existingItemsMap.get(source.id);
                    
                    if (item && !forceUpdate) {
                        // 更新现有元素
                        this.updateSourceItem(item, source);
                    } else {
                        // 创建新元素
                        item = this.createSourceItem(source);
                    }
                    fragment.appendChild(item);
                });
            }
            
            // 一次性替换所有子元素
            container.innerHTML = '';
            container.appendChild(fragment);
            
            // 更新勾选统计
            this.updateSelectionStats();
        };
        
        // 关键修复：导入后立即执行，不延迟
        if (forceUpdate) {
            updateFunction();
        } else {
            domUpdateQueue.enqueue(updateFunction);
        }
    },
    
    // 创建源列表项 - 修改：增加复选框
    createSourceItem: function(source) {
        const item = document.createElement('div');
        item.className = 'source-item';
        item.setAttribute('data-id', source.id);
        
        return this.updateSourceItem(item, source, true);
    },
    
    // 更新源列表项 - 修改：增加复选框
    updateSourceItem: function(item, source, isNew = false) {
        // 高亮当前播放的源
        if (source.id === state.sources[state.currentPlayingIndex]?.id) {
            item.style.cssText = 'background: #f0f8ff; border-left: 3px solid #2c80ff;';
        } else {
            item.style.cssText = '';
        }
        
        const statusConfig = {
            pending: { color: '#ccc', text: '待检测', timeClass: 'pending' },
            success: { color: '#4CAF50', text: '有效', timeClass: 'success' },
            failed: { color: '#f44336', text: '无效', timeClass: 'failed' }
        };
        
        const config = statusConfig[source.status] || statusConfig.pending;
        if (source.testing) {
            config.color = '#2c80ff';
            config.text = '检测中';
        }
        
        const timeDisplay = source.checkTime !== null ? source.checkTime.toFixed(2) + 's' : 
                          source.testing ? '检测中...' : '--';
        
        const groupInfo = source.group && source.group !== '未分组' ? 
            `<div style="font-size: 9px; color: #888; margin-top: 2px;">分组: ${source.group}</div>` : '';
        
        // 检查是否被勾选 - 修复：使用新的方法
        const isChecked = state.isSourceSelected(source.id);
        
        if (isNew || !item.innerHTML) {
            item.innerHTML = `
                <input type="checkbox" class="source-checkbox" data-id="${source.id}" ${isChecked ? 'checked' : ''}>
                <div style="width: 16px; height: 16px; border-radius: 50%; background: ${config.color}; margin-right: 8px; flex-shrink: 0;"></div>
                <div style="flex: 1; min-width: 0;">
                    <div class="channel-name" title="${source.name}">${source.name}</div>
                    <div class="channel-url" title="${source.url}">${source.url}</div>
                    <div style="display: flex; align-items: center;">
                        <span class="check-time ${config.timeClass}">检测: ${timeDisplay}</span>
                    </div>
                    ${groupInfo}
                </div>
                <div class="right-section">
                    <button class="play-btn" style="padding: 6px 10px; font-size: 12px; min-width: 50px;" data-id="${source.id}">播放</button>
                    <div style="padding: 6px 8px; color: #666; font-size: 11px; white-space: nowrap;">${config.text}</div>
                </div>
            `;
        } else {
            // 只更新需要变化的部分
            const checkbox = item.querySelector('.source-checkbox');
            const statusDot = item.querySelector('div[style*="width: 16px"]');
            const checkTime = item.querySelector('.check-time');
            const statusText = item.querySelector('.right-section > div:last-child');
            const playBtn = item.querySelector('.play-btn');
            
            if (checkbox) checkbox.checked = isChecked;
            if (statusDot) statusDot.style.background = config.color;
            if (checkTime) {
                checkTime.textContent = `检测: ${timeDisplay}`;
                checkTime.className = `check-time ${config.timeClass}`;
            }
            if (statusText) statusText.textContent = config.text;
            if (playBtn) playBtn.setAttribute('data-id', source.id);
            
            // 更新分组信息
            const groupInfoDiv = item.querySelector('div[style*="font-size: 9px"]');
            if (groupInfo) {
                if (!groupInfoDiv) {
                    const infoContainer = item.querySelector('div[style*="flex: 1"]');
                    if (infoContainer) {
                        const newGroupInfo = document.createElement('div');
                        newGroupInfo.style.cssText = 'font-size: 9px; color: #888; margin-top: 2px;';
                        newGroupInfo.textContent = `分组: ${source.group}`;
                        const checkTimeDiv = infoContainer.querySelector('div[style*="display: flex"]');
                        if (checkTimeDiv) {
                            infoContainer.insertBefore(newGroupInfo, checkTimeDiv.nextSibling);
                        }
                    }
                } else {
                    groupInfoDiv.textContent = `分组: ${source.group}`;
                }
            } else if (groupInfoDiv) {
                groupInfoDiv.remove();
            }
        }
        
        return item;
    },
    
    // 更新单个源列表项（用于检测状态更新）
    updateSingleSourceItem: function(sourceId) {
        const container = domCache.get('sourceList');
        const item = container.querySelector(`.source-item[data-id="${sourceId}"]`);
        
        if (item) {
            const source = state.sourceById.get(sourceId);
            if (source) {
                this.updateSourceItem(item, source);
            }
        }
    }
};

// ==================== 事件处理 ====================

const handlers = {
    handleGroupToggle: function(e, groupName) {
        if (state.testing) {
            utils.showMsg('检测进行中，无法修改分组选择', 'error');
            return;
        }
        
        const group = state.groups.find(g => g.name === groupName);
        if (group) {
            group.selected = !group.selected;
            group.selected ? state.selectedGroups.add(groupName) : state.selectedGroups.delete(groupName);
            state.allGroupsSelected = state.groups.length > 0 && state.groups.every(g => g.selected);
            ui.refreshGroupSelector();
            ui.refreshGroupModal();
            ui.updateSourceList();
            ui.updateStats();
            ui.updateSelectionStats(); // 新增：更新勾选统计
        }
    },
    
    handleSelectAllGroups: function(e) {
        if (state.testing) {
            utils.showMsg('检测进行中，无法修改分组选择', 'error');
            return;
        }
        
        state.groups.forEach(group => {
            group.selected = true;
            state.selectedGroups.add(group.name);
        });
        state.allGroupsSelected = true;
        ui.refreshGroupSelector();
        ui.refreshGroupModal();
        ui.updateSourceList();
        ui.updateStats();
        ui.updateSelectionStats(); // 新增：更新勾选统计
        utils.showMsg('已选择所有分组');
    },
    
    handleClearAllGroups: function(e) {
        if (state.testing) {
            utils.showMsg('检测进行中，无法修改分组选择', 'error');
            return;
        }
        
        state.groups.forEach(group => group.selected = false);
        state.selectedGroups.clear();
        state.allGroupsSelected = false;
        ui.refreshGroupSelector();
        ui.refreshGroupModal();
        ui.updateSourceList();
        ui.updateStats();
        ui.updateSelectionStats(); // 新增：更新勾选统计
        utils.showMsg('已清除所有分组选择');
    },
    
    handleFileImport: function() {
        domCache.get('fileInput').click();
    },
    
    handleFileChange: function(e) {
        const file = e.target.files[0];
        if (!file) return;
        
        const reader = new FileReader();
        reader.onload = (e) => {
            parser.parseContent(e.target.result);
            // 关键修复：确保列表更新完成
            setTimeout(() => {
                ui.updateSourceList(true);
                utils.showMsg(`已导入${state.sources.length}个频道`);
            }, 50);
        };
        reader.readAsText(file);
    },
    
    handleUrlImport: async function() {
        const url = domCache.get('urlInput').value.trim();
        
        if (!url) {
            utils.showMsg('请输入URL地址', 'error');
            return;
        }
        
        if (!utils.isValidUrl(url)) {
            utils.showMsg('请输入有效的URL地址', 'error');
            return;
        }
        
        const btn = domCache.get('urlImportBtn');
        const loadingIndicator = domCache.get('loadingIndicator');
        const originalText = btn.textContent;
        
        btn.textContent = '导入中...';
        btn.disabled = true;
        loadingIndicator.style.display = 'block';
        
        try {
            const content = await utils.fetchUrlContent(url);
            if (content) {
                parser.parseContent(content);
                // 关键修复：确保列表更新完成
                setTimeout(() => {
                    ui.updateSourceList(true);
                    utils.showMsg(`已从URL导入${state.sources.length}个频道`);
                }, 50);
            } else {
                utils.showMsg('无法获取内容，请检查URL或网络', 'error');
            }
        } catch (error) {
            utils.showMsg('导入失败: ' + (error.message || '请检查网络连接'), 'error');
        } finally {
            btn.textContent = originalText;
            btn.disabled = false;
            loadingIndicator.style.display = 'none';
        }
    },
    
    handleFilter: function(e, target) {
        state.currentFilter = target.dataset.filter;
        document.querySelectorAll('.filter-btn').forEach(btn => btn.classList.remove('active'));
        target.classList.add('active');
        ui.updateSourceList(true);
        ui.updateSelectionStats(); // 新增：更新勾选统计
    },
    
    // 新增：处理复选框点击
    handleCheckboxClick: function(e, target) {
        const sourceId = target.dataset.id;
        if (sourceId) {
            state.toggleSourceSelection(sourceId);
            ui.updateSelectionStats();
            ui.updateExportButton();
        }
    },
    
    // 新增：处理全选按钮点击
    handleSelectAllClick: function() {
        const wasSelected = state.toggleSelectAll();
        ui.updateSourceList();
        ui.updateSelectionStats();
        ui.updateExportButton();
        utils.showMsg(wasSelected ? '已全选当前列表' : '已取消全选当前列表');
    },
    
    handleSliderChange: function(e) {
        const target = e.target;
        const value = target.value;
        
        switch (target.id) {
            case 'timeoutSlider':
                domCache.get('timeoutValue').textContent = value;
                break;
            case 'delaySlider':
                domCache.get('delayValue').textContent = value;
                break;
            case 'concurrencySlider':
                domCache.get('concurrencyValue').textContent = value;
                break;
        }
    },
    
    handleStart: async function() {
        if (!state.sources.length) {
            utils.showMsg('请先导入直播源', 'error');
            return;
        }
        
        const selectedSourcesCount = state.getSelectedSourcesCount();
        if (!selectedSourcesCount) {
            utils.showMsg('请先选择要检测的分组', 'error');
            return;
        }
        
        if (state.paused) {
            state.paused = false;
            domCache.get('pause').textContent = '暂停检测';
            utils.showMsg('检测已恢复');
            
            if (state.activeTasks < state.concurrency && state.nextIndex < selectedSourcesCount) {
                controller.startIncremental();
            }
            return;
        }
        
        if (state.testing) {
            utils.showMsg('检测正在进行中', 'error');
            return;
        }
        
        state.testing = true;
        state.abortController = new AbortController();
        
        state.currentFilter = 'all';
        const allFilterBtn = document.querySelector('.filter-btn[data-filter="all"]');
        if (allFilterBtn) allFilterBtn.click();
        
        ui.updateSourceList(true);
        ui.updateStats();
        ui.updateConcurrencyStatus();
        ui.updateQueueDisplay();
        
        const startBtn = domCache.get('start');
        const pauseBtn = domCache.get('pause');
        
        startBtn.textContent = '检测中...';
        startBtn.disabled = true;
        pauseBtn.disabled = false;
        
        controller.startConcurrentTesting();
    },
    
    handlePause: function() {
        if (!state.testing) return;
        
        state.paused = !state.paused;
        const pauseBtn = domCache.get('pause');
        pauseBtn.textContent = state.paused ? '继续检测' : '暂停检测';
        
        if (state.paused) {
            utils.showMsg('检测已暂停');
            if (state.startTimer) {
                clearTimeout(state.startTimer);
                state.startTimer = null;
            }
        } else {
            utils.showMsg('检测已恢复');
            const selectedSourcesCount = state.getSelectedSourcesCount();
            if (state.activeTasks < state.concurrency && state.nextIndex < selectedSourcesCount) {
                controller.startIncremental();
            }
        }
    },
    
    handleOpenSettingsModal: function() {
        if (state.testing) {
            utils.showMsg('检测进行中，无法修改设置', 'error');
            return;
        }
        
        domCache.get('settingsModal').classList.add('show');
        document.body.style.overflow = 'hidden';
    },
    
    handleCloseSettingsModal: function() {
        domCache.get('settingsModal').classList.remove('show');
        document.body.style.overflow = '';
    },
    
    handleSaveSettings: function() {
        // 更新状态中的设置值
        state.delayTime = parseInt(domCache.get('delaySlider').value);
        state.concurrency = parseInt(domCache.get('concurrencySlider').value);
        
        // 更新显示
        domCache.get('currentConcurrency').textContent = state.concurrency;
        
        domCache.get('settingsModal').classList.remove('show');
        document.body.style.overflow = '';
        
        utils.showMsg('设置已保存');
    },
    
    handleOpenModal: function() {
        if (state.testing) {
            utils.showMsg('检测进行中，无法修改分组选择', 'error');
            return;
        }
        
        domCache.get('groupSelectorModal').classList.add('show');
        document.body.style.overflow = 'hidden';
    },
    
    handleCloseModal: function() {
        domCache.get('groupSelectorModal').classList.remove('show');
        document.body.style.overflow = '';
    },
    
    handleExample: function(e, target) {
        const examples = {
            gitee: 'https://gitee.com/mirrors_iptv/iptv/raw/master/streams/cn.m3u',
            direct: 'https://iptv-org.github.io/iptv/countries/cn.m3u'
        };
        domCache.get('urlInput').value = examples[target.dataset.example] || '';
    },
    
    handleSourceListClick: function(e, target) {
        const sourceId = target.dataset.id;
        if (sourceId) {
            const index = state.sources.findIndex(s => s.id === sourceId);
            if (index !== -1) {
                controller.playSource(index);
            }
        }
    },
    
    handleStopPlayback: function() {
        controller.stopPlayback();
    },
    
    handleModalClick: function(e) {
        if (e.target === domCache.get('groupSelectorModal')) {
            this.handleCloseModal();
        }
        if (e.target === domCache.get('settingsModal')) {
            this.handleCloseSettingsModal();
        }
    },
    
    // 新增：关闭视频弹窗
    handleCloseVideoModal: function() {
        controller.closeVideoModal();
    },
    
    // 新增：导出勾选频道 - 修复版
    handleExportSelected: function() {
        controller.exportSelectedSources();
    }
};

// ==================== 控制器 ====================

const controller = {
    stopTesting: function() {
        if (state.abortController) {
            state.abortController.abort();
            state.abortController = null;
        }
        
        if (state.startTimer) {
            clearTimeout(state.startTimer);
            state.startTimer = null;
        }
        
        state.sources.forEach(source => {
            if (source.testing) {
                source.testing = false;
                source.status = 'pending';
            }
        });
        
        Object.assign(state, {
            activeTasks: 0,
            taskQueue: [],
            nextIndex: 0,
            testing: false
        });
        
        ui.updateConcurrencyStatus();
        ui.updateSourceList(true);
        this.enableGroupSelector(true);
        this.enableSettingsBtn(true);
    },
    
    resetTesting: function() {
        const selectedSources = state.getSelectedSources();
        selectedSources.forEach(source => {
            source.status = 'pending';
            source.testing = false;
            source.checkTime = null;
            source.startTime = null;
        });
        
        Object.assign(state, {
            completed: 0,
            valid: [],
            activeTasks: 0,
            taskQueue: [],
            nextIndex: 0
        });
        
        ui.updateStats();
        ui.updateProgress();
        ui.updateConcurrencyStatus();
        ui.updateQueueDisplay();
    },
    
    enableGroupSelector: function(enable) {
        const selectorBtn = domCache.get('groupSelectorBtn');
        selectorBtn.disabled = !enable;
        selectorBtn.style.cursor = enable ? 'pointer' : 'not-allowed';
        
        if (!enable) {
            domCache.get('groupSelectorModal').classList.remove('show');
            document.body.style.overflow = '';
        }
    },
    
    enableSettingsBtn: function(enable) {
        const settingsBtn = domCache.get('settingsBtn');
        settingsBtn.disabled = !enable;
        settingsBtn.style.cursor = enable ? 'pointer' : 'not-allowed';
        
        if (!enable) {
            domCache.get('settingsModal').classList.remove('show');
            document.body.style.overflow = '';
        }
    },
    
    testSingleSource: function(source, timeout) {
        return new Promise((resolve) => {
            if (!state.testing || state.paused) {
                resolve({ result: false, checkTime: 0 });
                return;
            }
            
            const startTime = performance.now();
            const video = document.createElement('video');
            video.muted = true;
            video.preload = 'auto';
            
            // 使用requestAnimationFrame进行更精确的计时
            const frameId = requestAnimationFrame(function check() {
                if (performance.now() - startTime >= timeout) {
                    const checkTime = (performance.now() - startTime) / 1000;
                    controller.cleanupVideo(video, frameId);
                    resolve({ result: false, checkTime });
                } else {
                    requestAnimationFrame(check);
                }
            });
            
            if (state.abortController) {
                state.abortController.signal.addEventListener('abort', () => {
                    const checkTime = (performance.now() - startTime) / 1000;
                    controller.cleanupVideo(video, frameId);
                    resolve({ result: false, checkTime });
                });
            }
            
            video.onloadeddata = () => {
                const checkTime = (performance.now() - startTime) / 1000;
                controller.cleanupVideo(video, frameId);
                resolve({ result: true, checkTime });
            };
            
            video.onerror = () => {
                const checkTime = (performance.now() - startTime) / 1000;
                controller.cleanupVideo(video, frameId);
                resolve({ result: false, checkTime });
            };
            
            video.src = source.url;
            video.load();
        });
    },
    
    cleanupVideo: function(video, frameId) {
        cancelAnimationFrame(frameId);
        video.src = '';
        video.load();
        video.remove();
    },
    
    startNewTask: function() {
        if (!state.testing || state.paused || state.activeTasks >= state.concurrency) return null;
        
        const selectedSources = state.getSelectedSources();
        if (state.nextIndex >= selectedSources.length) return null;
        
        const source = selectedSources[state.nextIndex];
        const taskIndex = state.nextIndex++;
        const timeout = parseInt(domCache.get('timeoutSlider').value) * 1000;
        
        source.testing = true;
        source.checkTime = null;
        source.startTime = Date.now();
        state.activeTasks++;
        
        const task = this.testSingleSource(source, timeout);
        
        state.taskQueue.push({ promise: task, index: taskIndex });
        
        task.then(async (resultObj) => {
            if (!state.testing) return;
            
            const taskIndexInQueue = state.taskQueue.findIndex(t => t.index === taskIndex);
            if (taskIndexInQueue > -1) state.taskQueue.splice(taskIndexInQueue, 1);
            state.activeTasks--;
            
            if (state.delayTime > 0) {
                await new Promise(resolve => setTimeout(resolve, state.delayTime));
            }
            
            if (!state.testing) return;
            
            source.testing = false;
            source.checkTime = resultObj.checkTime;
            source.status = resultObj.result ? 'success' : 'failed';
            
            // 更新状态映射
            state.updateSource(source);
            
            if (resultObj.result) state.valid.push(source);
            state.completed++;
            
            // 批量更新UI
            ui.updateProgress();
            ui.updateStats();
            
            // 关键修复：更新单个源的状态显示
            ui.updateSingleSourceItem(source.id);
            
            ui.updateConcurrencyStatus();
            ui.updateQueueDisplay();
            
            const selectedSourcesCount = selectedSources.length;
            if (state.completed === selectedSourcesCount) {
                this.finishTesting();
            } else if (state.activeTasks < state.concurrency && state.nextIndex < selectedSourcesCount) {
                this.startNewTask();
            }
        }).catch((error) => {
            console.error('任务执行失败:', error);
            const taskIndexInQueue = state.taskQueue.findIndex(t => t.index === taskIndex);
            if (taskIndexInQueue > -1) state.taskQueue.splice(taskIndexInQueue, 1);
            state.activeTasks--;
            ui.updateConcurrencyStatus();
            ui.updateQueueDisplay();
        });
        
        ui.updateConcurrencyStatus();
        ui.updateQueueDisplay();
        ui.updateSingleSourceItem(source.id);
        
        return task;
    },
    
    startIncremental: function() {
        if (!state.testing || state.paused) return;
        
        const selectedSourcesCount = state.getSelectedSourcesCount();
        if (state.activeTasks >= state.concurrency || state.nextIndex >= selectedSourcesCount) {
            if (state.startTimer) {
                clearTimeout(state.startTimer);
                state.startTimer = null;
            }
            return;
        }
        
        this.startNewTask();
        
        if (state.activeTasks < state.concurrency && state.nextIndex < selectedSourcesCount) {
            state.startTimer = setTimeout(() => this.startIncremental(), state.startInterval);
        }
    },
    
    startConcurrentTesting: function() {
        const selectedSources = state.getSelectedSources();
        if (!selectedSources.length || !state.testing) {
            utils.showMsg('请先选择要检测的分组', 'error');
            state.testing = false;
            const startBtn = domCache.get('start');
            startBtn.textContent = '开始检测';
            startBtn.disabled = false;
            return;
        }
        
        this.resetTesting();
        this.enableGroupSelector(false);
        this.enableSettingsBtn(false);
        this.startNewTask();
        
        if (state.concurrency > 1) {
            state.startTimer = setTimeout(() => this.startIncremental(), state.startInterval);
        }
    },
    
    finishTesting: function() {
        state.testing = false;
        const startBtn = domCache.get('start');
        const pauseBtn = domCache.get('pause');
        
        startBtn.textContent = '开始检测';
        startBtn.disabled = false;
        pauseBtn.disabled = true;
        
        if (state.startTimer) {
            clearTimeout(state.startTimer);
            state.startTimer = null;
        }
        
        this.enableGroupSelector(true);
        this.enableSettingsBtn(true);
        utils.showMsg('检测完成');
    },
    
    cleanupVideoListeners: function() {
        const videoPlayer = domCache.get('videoPlayer');
        Object.entries(state.videoListeners).forEach(([event, handler]) => {
            videoPlayer.removeEventListener(event, handler);
        });
        state.videoListeners = {};
    },
    
    resetPlayerState: function() {
        const videoPlayer = domCache.get('videoPlayer');
        const videoModalStatus = domCache.get('videoModalStatus');
        const videoModalInfo = domCache.get('videoModalInfo');
        const videoStopBtn = domCache.get('videoStopBtn');
        
        videoPlayer.pause();
        videoPlayer.currentTime = 0;
        videoPlayer.src = '';
        videoPlayer.load();
        
        Object.assign(state, {
            isPlaying: false,
            loadTimeout: null
        });
        
        videoModalStatus.textContent = '未播放';
        videoModalStatus.className = 'video-modal-status idle';
        videoModalInfo.textContent = '未选择频道';
        videoStopBtn.disabled = true;
    },
    
    stopPlayback: function() {
        this.cleanupVideoListeners();
        this.resetPlayerState();
        
        if (state.currentPlayingIndex !== -1) {
            ui.updateSingleSourceItem(state.sources[state.currentPlayingIndex]?.id);
            state.currentPlayingIndex = -1;
        }
        
        utils.showMsg('播放已停止', 'success');
    },
    
    // 关闭视频弹窗
    closeVideoModal: function() {
        const videoModal = domCache.get('videoModal');
        videoModal.classList.remove('show');
        
        this.stopPlayback();
    },
    
    playSource: function(index) {
        const source = state.sources[index];
        
        if (state.currentPlayingIndex === index && state.isPlaying) {
            this.stopPlayback();
            return;
        }
        
        if (state.isPlaying) {
            this.cleanupVideoListeners();
            this.resetPlayerState();
        }
        
        state.currentPlayingIndex = index;
        const videoPlayer = domCache.get('videoPlayer');
        const videoModalStatus = domCache.get('videoModalStatus');
        const videoModalInfo = domCache.get('videoModalInfo');
        const videoStopBtn = domCache.get('videoStopBtn');
        const videoModal = domCache.get('videoModal');
        
        // 显示弹窗（悬浮模式，不需要修改body样式）
        videoModal.classList.add('show');
        
        videoModalStatus.textContent = '加载中...';
        videoModalStatus.className = 'video-modal-status loading';
        videoModalInfo.textContent = `正在加载: ${source.name}`;
        videoStopBtn.disabled = false;
        
        videoPlayer.src = source.url;
        videoPlayer.load();
        
        state.loadTimeout = setTimeout(() => {
            if (state.isPlaying || videoPlayer.readyState === 0) {
                this.handlePlayError('加载超时（15秒）');
            }
        }, 15000);
        
        this.setupVideoListeners(source);
        
        videoPlayer.play().then(() => {
            if (state.loadTimeout) {
                clearTimeout(state.loadTimeout);
                state.loadTimeout = null;
            }
            
            state.isPlaying = true;
            videoModalStatus.textContent = '播放中';
            videoModalStatus.className = 'video-modal-status playing';
            videoModalInfo.textContent = `正在播放: ${source.name} (分组: ${source.group})`;
            
            // 更新列表项的高亮状态
            ui.updateSingleSourceItem(source.id);
            
            utils.showMsg(`开始播放: ${source.name}`, 'success');
        }).catch((error) => {
            console.log('自动播放失败:', error.message);
            
            videoModalStatus.textContent = '已加载，点击播放按钮开始';
            videoModalStatus.className = 'video-modal-status idle';
            videoModalInfo.textContent = `已加载: ${source.name} (分组: ${source.group})`;
            
            utils.showMsg('视频已加载，请手动点击播放按钮', 'success');
            
            if (state.loadTimeout) {
                clearTimeout(state.loadTimeout);
                state.loadTimeout = null;
            }
        });
    },
    
    setupVideoListeners: function(source) {
        const videoPlayer = domCache.get('videoPlayer');
        const videoModalStatus = domCache.get('videoModalStatus');
        const videoModalInfo = domCache.get('videoModalInfo');
        
        const on = (event, handler) => {
            state.videoListeners[event] = handler;
            videoPlayer.addEventListener(event, handler);
        };
        
        on('playing', () => {
            state.isPlaying = true;
            videoModalStatus.textContent = '播放中';
            videoModalStatus.className = 'video-modal-status playing';
            if (state.loadTimeout) {
                clearTimeout(state.loadTimeout);
                state.loadTimeout = null;
            }
        });
        
        on('pause', () => {
            state.isPlaying = false;
            videoModalStatus.textContent = '已暂停';
            videoModalStatus.className = 'video-modal-status idle';
        });
        
        on('ended', () => {
            state.isPlaying = false;
            videoModalStatus.textContent = '播放结束';
            videoModalStatus.className = 'video-modal-status idle';
            utils.showMsg(`播放结束: ${source.name}`, 'success');
        });
        
        on('error', (e) => {
            console.error('视频播放错误:', e);
            this.handlePlayError('视频播放错误');
        });
        
        on('loadeddata', () => {
            videoModalStatus.textContent = '已加载';
            videoModalStatus.className = 'video-modal-status idle';
            if (state.loadTimeout) {
                clearTimeout(state.loadTimeout);
                state.loadTimeout = null;
            }
        });
        
        on('waiting', () => {
            videoModalStatus.textContent = '缓冲中...';
            videoModalStatus.className = 'video-modal-status loading';
        });
    },
    
    handlePlayError: function(errorMessage) {
        this.cleanupVideoListeners();
        this.resetPlayerState();
        
        const videoModalStatus = domCache.get('videoModalStatus');
        const videoModalInfo = domCache.get('videoModalInfo');
        
        videoModalStatus.textContent = '播放失败';
        videoModalStatus.className = 'video-modal-status error';
        videoModalInfo.textContent = `播放失败: ${state.sources[state.currentPlayingIndex]?.name || '未知频道'}`;
        
        console.error('播放失败:', errorMessage);
        utils.showMsg(`播放失败: ${errorMessage}`, 'error');
        
        if (state.currentPlayingIndex !== -1) {
            ui.updateSingleSourceItem(state.sources[state.currentPlayingIndex]?.id);
            state.currentPlayingIndex = -1;
        }
    },
    
    // 修改：导出所有在线源（不考虑勾选）
    exportSources: function() {
        if (!state.sources.length) {
            utils.showMsg('没有可导出的直播源', 'error');
            return;
        }
        
        const sourcesToExport = state.sources.filter(s => s.status === 'success');
        if (!sourcesToExport.length) {
            utils.showMsg('没有在线的直播源可导出', 'error');
            return;
        }
        
        const groupsContent = {};
        sourcesToExport.forEach(source => {
            const groupName = source.group || '默认分组';
            if (!groupsContent[groupName]) groupsContent[groupName] = [];
            groupsContent[groupName].push(source);
        });
        
        let exportContent = '';
        Object.entries(groupsContent).forEach(([groupName, groupSources]) => {
            const groupInfo = state.groupInfoMap.get(groupName);
            if (groupInfo?.type === 'genre' && groupInfo.originalLine) {
                exportContent += groupInfo.originalLine + '\n';
            }
            
            groupSources.forEach(source => {
                if (source.originalContent) {
                    exportContent += source.originalContent + '\n';
                } else if (source.extinf) {
                    exportContent += source.extinf + '\n' + source.url + '\n';
                } else {
                    exportContent += `${source.name},${source.url}\n`;
                }
            });
        });
        
        const blob = new Blob([exportContent], { type: 'text/plain;charset=utf-8' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `online_sources_${new Date().toISOString().replace(/[:.]/g, '-')}.txt`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        utils.showMsg(`已导出${sourcesToExport.length}个在线频道`);
    },
    
    // 新增：导出勾选频道 - 修复版
    exportSelectedSources: function() {
        const selectedCount = state.getSelectedCount();
        console.log('导出勾选频道，选中数量:', selectedCount, '选中源:', state.selectedSources);
        
        if (selectedCount === 0) {
            utils.showMsg('请先勾选要导出的频道', 'error');
            return;
        }
        
        // 获取所有被勾选的源对象 - 修复：直接从state.sources中筛选
        const selectedSources = state.sources.filter(source => state.selectedSources[source.id]);
        console.log('筛选出的选中源:', selectedSources);
        
        if (selectedSources.length === 0) {
            utils.showMsg('没有找到勾选的频道，请重新勾选', 'error');
            return;
        }
        
        // 按分组组织源
        const groupsContent = {};
        selectedSources.forEach(source => {
            const groupName = source.group || '默认分组';
            if (!groupsContent[groupName]) groupsContent[groupName] = [];
            groupsContent[groupName].push(source);
        });
        
        // 构建导出内容
        let exportContent = '';
        Object.entries(groupsContent).forEach(([groupName, groupSources]) => {
            const groupInfo = state.groupInfoMap.get(groupName);
            if (groupInfo?.type === 'genre' && groupInfo.originalLine) {
                exportContent += groupInfo.originalLine + '\n';
            }
            
            groupSources.forEach(source => {
                if (source.originalContent) {
                    exportContent += source.originalContent + '\n';
                } else if (source.extinf) {
                    exportContent += source.extinf + '\n' + source.url + '\n';
                } else {
                    exportContent += `${source.name},${source.url}\n`;
                }
            });
        });
        
        // 创建下载链接
        const blob = new Blob([exportContent], { type: 'text/plain;charset=utf-8' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `selected_sources_${new Date().toISOString().replace(/[:.]/g, '-')}.txt`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        utils.showMsg(`已导出${selectedSources.length}个勾选频道`);
        
        // 导出后清空勾选状态
        state.clearAllSelections();
        ui.updateSelectionStats();
        ui.updateExportButton();
        ui.updateSourceList();
    }
};

// ==================== 初始化 ====================

const init = function() {
    perfMonitor.start();
    
    // 使用事件委托优化事件绑定
    eventDelegate.add(document, '.filter-btn', 'click', handlers.handleFilter);
    eventDelegate.add(document, '.example-link', 'click', handlers.handleExample);
    eventDelegate.add(domCache.get('sourceList'), '.play-btn', 'click', handlers.handleSourceListClick);
    eventDelegate.add(domCache.get('sourceList'), '.source-checkbox', 'click', handlers.handleCheckboxClick);
    
    // 直接事件绑定
    domCache.get('fileImportBtn').addEventListener('click', handlers.handleFileImport);
    domCache.get('fileInput').addEventListener('change', handlers.handleFileChange);
    domCache.get('urlImportBtn').addEventListener('click', handlers.handleUrlImport);
    domCache.get('videoStopBtn').addEventListener('click', handlers.handleStopPlayback);
    domCache.get('closeVideoModalBtn').addEventListener('click', handlers.handleCloseVideoModal);
    domCache.get('start').addEventListener('click', handlers.handleStart);
    domCache.get('pause').addEventListener('click', handlers.handlePause);
    domCache.get('settingsBtn').addEventListener('click', handlers.handleOpenSettingsModal);
    domCache.get('closeSettingsBtn').addEventListener('click', handlers.handleCloseSettingsModal);
    domCache.get('saveSettings').addEventListener('click', handlers.handleSaveSettings);
    domCache.get('groupSelectorBtn').addEventListener('click', handlers.handleOpenModal);
    domCache.get('closeModalBtn').addEventListener('click', handlers.handleCloseModal);
    domCache.get('modalSelectAllBtn').addEventListener('click', handlers.handleSelectAllGroups);
    domCache.get('modalClearAllBtn').addEventListener('click', handlers.handleClearAllGroups);
    domCache.get('exportOnline').addEventListener('click', controller.exportSources);
    domCache.get('exportSelected').addEventListener('click', handlers.handleExportSelected);
    domCache.get('selectAllBtn').addEventListener('click', handlers.handleSelectAllClick);
    domCache.get('groupSelectorModal').addEventListener('click', handlers.handleModalClick.bind(handlers));
    domCache.get('settingsModal').addEventListener('click', handlers.handleModalClick.bind(handlers));
    
    // 滑动条事件
    [domCache.get('timeoutSlider'), 
     domCache.get('delaySlider'), 
     domCache.get('concurrencySlider')].forEach(slider => {
        if (slider) {
            slider.addEventListener('input', handlers.handleSliderChange);
        }
    });
    
    // 输入框回车事件
    domCache.get('urlInput').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') handlers.handleUrlImport();
    });
    
    // 初始化UI
    controller.resetPlayerState();
    ui.updateStats();
    ui.updateConcurrencyStatus();
    ui.refreshGroupModal();
    ui.updateExportButton();
    ui.updateSelectionStats();
    
    console.log(`直播源检测工具 v${VERSION} (悬浮弹窗播放版 + 勾选导出功能)`);
    console.log('性能监控已启用');
    
    // 页面加载完成后执行
    requestAnimationFrame(() => {
        document.body.style.opacity = '1';
        
        // 添加性能监控显示（调试用）
        if (window.location.search.includes('debug=perf')) {
            const perfDiv = document.createElement('div');
            perfDiv.style.cssText = 'position:fixed;bottom:10px;right:10px;background:rgba(0,0,0,0.7);color:#fff;padding:10px;font-size:12px;z-index:9999;border-radius:5px;';
            perfDiv.innerHTML = '性能监控<br>操作数: <span id="perfOps">0</span><br>DOM更新: <span id="perfDOM">0</span>';
            document.body.appendChild(perfDiv);
            
            setInterval(() => {
                const stats = perfMonitor.getStats();
                const perfOps = document.getElementById('perfOps');
                const perfDOM = document.getElementById('perfDOM');
                if (perfOps) perfOps.textContent = stats.operations;
                if (perfDOM) perfDOM.textContent = stats.domUpdates;
            }, 1000);
        }
    });
    
    // 清理
    window.addEventListener('beforeunload', () => {
        controller.stopTesting();
        controller.stopPlayback();
        domUpdateQueue.flush();
        domCache.clear();
    });
    
    // 添加内存清理
    window.addEventListener('visibilitychange', () => {
        if (document.hidden) {
            // 页面隐藏时清理一些临时数据
            domUpdateQueue.flush();
        }
    });
};

// ==================== 启动应用 ====================

// 等待DOM加载完成
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
} else {
    init();
}
</script>
</body>
</html>
