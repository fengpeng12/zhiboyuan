<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>直播源管理</title>
<style>
* {box-sizing: border-box;}
body{margin:0;padding:10px;background:#f5f5f5;font-family:sans-serif}
.container{width:100%;margin:0 auto}
.header{text-align:center;padding:15px 10px;border-bottom:2px solid #007bff}
.header h1{color:#007bff;margin:0;font-size:clamp(20px, 6vw, 28px)}
.section{background:#fff;border-radius:8px;padding:15px;margin:15px 0}
.info{padding:10px;background:#e9f5ff;border-radius:6px;margin-bottom:15px;font-size:clamp(16px, 4vw, 20px)}
.info span{color:#007bff;font-weight:bold}
.buttons{display:flex;flex-wrap:wrap;gap:8px;margin:10px 0}
.btn{
    padding:12px 16px;
    border-radius:8px;
    border:none;
    cursor:pointer;
    flex:1;
    min-width:calc(33.33% - 8px);
    color:#fff;
    font-size:clamp(16px, 4.5vw, 20px);
    text-align:center;
    font-weight:bold;
    transition:all 0.2s ease;
}
.btn:hover{
    transform:translateY(-2px);
    box-shadow:0 4px 8px rgba(0,0,0,0.2);
}
.btn.blue{background:#007bff}
.btn.red{background:#dc3545}
.btn.green{background:#28a745}
.btn.purple{background:#6f42c1}
.btn.yellow{background:#ffc107;color:#333}
.btn.gray{background:#6c757d}
.source-list{border:1px solid #ddd;border-radius:6px;padding:10px;max-height:50vh;overflow:auto}
.source-item{padding:8px;margin-bottom:5px;background:#f8f9fa;border-radius:4px;display:flex;flex-wrap:wrap;align-items:center;gap:8px}
.channel-name{font-weight:bold;color:#333;min-width:120px;flex:1;font-size:clamp(14px, 3.5vw, 18px);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
.source-url{flex:2;word-break:break-all;font-size:clamp(12px, 3vw, 16px);color:#666;min-width:200px}
.status-badge{padding:4px 8px;border-radius:4px;font-size:clamp(12px, 3vw, 16px);color:#fff;min-width:50px;text-align:center}
.status-valid{background:#28a745}
.status-invalid{background:#dc3545}
.status-unknown{background:#6c757d}
.empty-list{text-align:center;padding:30px;color:#999;font-size:clamp(16px, 5vw, 24px)}
.modal{display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.5);z-index:1000}
.modal-content{background:#fff;border-radius:8px;width:95%;max-width:800px;margin:20px auto;max-height:90vh;display:flex;flex-direction:column}
.modal-header{padding:15px 20px;background:#007bff;color:#fff;border-radius:8px 8px 0 0;font-size:clamp(18px, 5vw, 24px)}
.modal-body{padding:20px;overflow:auto;flex:1}
.modal-footer{padding:15px 20px;text-align:right}
.url-input{width:100%;padding:12px;border:1px solid #ddd;border-radius:4px;margin-bottom:10px;font-size:clamp(16px, 4vw, 20px)}
.status{padding:10px;border-radius:4px;margin:10px 0;display:none;font-size:clamp(14px, 3.5vw, 18px)}
.status.success{background:#d4edda;color:#155724}
.status.error{background:#f8d7da;color:#721c24}
.group-grid{display:grid;grid-template-columns:repeat(auto-fill, minmax(120px, 1fr));gap:12px;margin-top:15px}
.group-item{padding:12px;border:1px solid #ddd;border-radius:8px;cursor:pointer;display:flex;flex-direction:column;align-items:center;text-align:center;transition:all 0.2s ease}
.group-item:hover{background:#f8f9fa;transform:translateY(-2px);box-shadow:0 2px 4px rgba(0,0,0,0.1)}
.group-item.selected{background:#e9f5ff;border-color:#007bff;box-shadow:0 0 0 2px rgba(0,123,255,0.3)}
.group-name{font-weight:bold;color:#007bff;font-size:clamp(14px, 3.5vw, 18px);overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;margin-bottom:4px}
.group-count{color:#666;font-size:clamp(13px, 3vw, 16px);font-weight:bold}
.group-checkbox{width:22px;height:22px;cursor:pointer;margin-bottom:10px}
.control-panel{margin:15px 0;padding:15px;background:#f8f9fa;border-radius:6px;border:1px solid #ddd}
.control-row{display:flex;flex-wrap:wrap;align-items:center;margin:12px 0;gap:12px}
.control-label{min-width:140px;font-weight:bold;color:#333;font-size:clamp(14px, 3.5vw, 18px);flex:1}
.control-slider{flex:2;min-width:150px;height:12px;}
.control-value{min-width:70px;text-align:right;color:#007bff;font-weight:bold;font-size:clamp(14px, 3.5vw, 18px)}
.progress-bar{width:100%;height:10px;background:#e9ecef;border-radius:4px;overflow:hidden;margin-top:12px}
.progress-fill{height:100%;background:#007bff;width:0%;transition:width 0.3s}
.detection-stats{display:grid;grid-template-columns:repeat(auto-fit, minmax(90px, 1fr));gap:12px;margin-top:12px;font-size:clamp(14px, 3.5vw, 18px)}
.stat-item{display:flex;flex-direction:column;align-items:center}
.stat-value{font-weight:bold;color:#007bff;font-size:clamp(16px, 4vw, 24px)}
.stat-label{font-size:clamp(13px, 3vw, 16px);color:#666}
.status-container{display:flex;flex-direction:column;align-items:flex-end;min-width:120px;flex-shrink:0}
.detection-time{font-size:clamp(12px, 2.5vw, 14px);color:#666;margin-top:2px;font-family:monospace}
.detection-time.valid{color:#28a745}
.detection-time.invalid{color:#dc3545}
.detection-time.unknown{color:#6c757d}
.filter-buttons{display:flex;gap:10px;margin:12px 0;flex-wrap:wrap}
.filter-btn{
    padding:8px 16px;
    border-radius:8px;
    border:1px solid #ddd;
    background:#fff;
    cursor:pointer;
    color:#666;
    font-size:clamp(14px, 3.5vw, 18px);
    flex:1;
    text-align:center;
    min-width:90px;
    font-weight:bold;
    transition:all 0.2s ease;
}
.filter-btn:hover{
    background:#f8f9fa;
    transform:translateY(-2px);
}
.filter-btn.active{
    background:#007bff;
    color:#fff;
    border-color:#007bff;
    box-shadow:0 2px 4px rgba(0,123,255,0.3);
}
.source-checkbox{width:22px;height:22px;cursor:pointer;flex-shrink:0}
.source-checkbox-label{display:flex;align-items:center;gap:10px;cursor:pointer;flex-shrink:0}
.selected-count{font-size:clamp(13px, 3vw, 16px);color:#007bff;margin-left:12px;font-weight:bold}
.list-header{display:flex;flex-wrap:wrap;justify-content:space-between;align-items:center;margin-bottom:12px;padding-bottom:12px;border-bottom:1px solid #eee;gap:12px}
.list-title{font-weight:bold;color:#333;font-size:clamp(14px, 3.5vw, 18px);flex:1}
.list-actions{display:flex;gap:10px;align-items:center;flex-wrap:wrap;justify-content:flex-end}
.btn.small{
    padding:8px 14px;
    font-size:clamp(14px, 3.5vw, 18px);
    min-width:auto;
    font-weight:bold;
}
.play-btn{
    padding:6px 12px;
    background:#6c757d;
    color:#fff;
    border:none;
    border-radius:6px;
    cursor:pointer;
    font-size:clamp(14px, 3.5vw, 18px);
    min-width:70px;
    flex-shrink:0;
    text-align:center;
    font-weight:bold;
    transition:all 0.2s ease;
}
.play-btn:hover{
    background:#5a6268;
    transform:translateY(-2px);
}
.play-btn.playing{background:#28a745}
.video-preview{
    display: block;
    position: relative;
    background:#fff;
    border-radius:8px;
    border:1px solid #ddd;
    margin:15px 0;
    overflow:hidden;
    box-shadow:0 2px 8px rgba(0,0,0,0.1);
}
.video-container{
    width:100%;
    display:flex;
    flex-direction:column;
}
.video-header{
    padding:12px 18px;
    background:#007bff;
    color:#fff;
    display:flex;
    justify-content:space-between;
    align-items:center;
    border-bottom:1px solid rgba(255,255,255,0.2);
}
.video-title{
    color:#fff;
    font-size:clamp(16px, 4vw, 20px);
    font-weight:bold;
    overflow:hidden;
    text-overflow:ellipsis;
    white-space:nowrap;
    max-width:70%;
}
.video-controls{
    display:flex;
    gap:10px;
    align-items:center;
}
.video-body{
    flex:1;
    display:flex;
    justify-content:center;
    align-items:center;
    padding:12px;
    background:#000;
    min-height:300px;
    max-height:600px;
}
#previewVideo{
    width:100%;
    height:auto;
    max-height:580px;
    object-fit:contain;
}
.video-placeholder {
    color: #999;
    font-size: clamp(16px, 4vw, 20px);
    text-align: center;
    padding: 20px;
}
@media (max-width: 768px) {
    .video-body {
        min-height: 250px;
        max-height: 400px;
    }
    #previewVideo {
        max-height: 380px;
    }
    .btn {
        padding: 10px 12px;
    }
    .btn.small {
        padding: 6px 10px;
    }
    .group-grid {
        grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
        gap: 8px;
    }
    .group-item {
        padding: 8px;
    }
}
#networkModal .modal-content {
    max-width: 800px;
}
#groupModal .modal-content {
    max-width: 900px;
}
#groupModal .modal-body {
    padding: 25px;
}
#groupModal .group-container p {
    font-size: clamp(16px, 4vw, 20px);
    margin-bottom: 20px;
    font-weight: bold;
}
#groupModal .modal-footer {
    padding: 20px 25px;
}
</style>
</head>
<body>
<div class="container">
  <div class="header"><h1>直播源管理</h1></div>
  
  <div class="section">
    <div class="info">已导入 <span id="totalCount">0</span> 个直播源 | <span id="groupCount">0</span> 个分组</div>
    <div class="buttons">
      <button class="btn blue" id="localImportBtn">本地导入</button>
      <button class="btn purple" id="networkImportBtn">网络导入</button>
      <button class="btn yellow" id="groupBtn">频道管理</button>
    </div>
  </div>
  
  <div class="section" id="detectionPanel">
    <div class="control-panel">
      <div class="info">直播源检测控制</div>
      
      <div class="control-row">
        <span class="control-label">检测超时(秒):</span>
        <input type="range" class="control-slider" id="timeoutSlider" min="1" max="20" value="5">
        <span class="control-value" id="timeoutValue">5秒</span>
      </div>
      
      <div class="control-row">
        <span class="control-label">检测间隔(毫秒):</span>
        <input type="range" class="control-slider" id="delaySlider" min="10" max="1000" value="200">
        <span class="control-value" id="delayValue">200ms</span>
      </div>
      
      <div class="control-row">
        <span class="control-label">并发数量:</span>
        <input type="range" class="control-slider" id="concurrencySlider" min="3" max="50" value="10">
        <span class="control-value" id="concurrencyValue">10个</span>
      </div>
      
      <div class="progress-bar">
        <div class="progress-fill" id="progressFill"></div>
      </div>
      
      <div class="detection-stats">
        <div class="stat-item">
          <span class="stat-value" id="processedCount">0</span>
          <span class="stat-label">已处理</span>
        </div>
        <div class="stat-item">
          <span class="stat-value" id="validDetectedCount">0</span>
          <span class="stat-label">有效</span>
        </div>
        <div class="stat-item">
          <span class="stat-value" id="invalidDetectedCount">0</span>
          <span class="stat-label">失效</span>
        </div>
        <div class="stat-item">
          <span class="stat-value" id="speedValue">0</span>
          <span class="stat-label">个/秒</span>
        </div>
        <div class="stat-item">
          <span class="stat-value" id="avgTimeValue">0ms</span>
          <span class="stat-label">平均耗时</span>
        </div>
      </div>
      
      <div class="buttons">
        <button class="btn green" id="testBtn">开始检测</button>
        <button class="btn red" id="clearBtn">清空列表</button>
      </div>
    </div>
  </div>
  
  <div class="video-preview" id="videoPreview">
    <div class="video-container">
      <div class="video-header">
        <div class="video-title" id="videoTitle">视频预览</div>
        <div class="video-controls">
          <button class="btn red small" id="closeVideoBtn">停止</button>
        </div>
      </div>
      <div class="video-body" id="videoBody">
        <div class="video-placeholder" id="videoPlaceholder">
          点击播放按钮开始预览视频
        </div>
        <video id="previewVideo" controls style="display:none"></video>
      </div>
    </div>
  </div>
  
  <div class="section">
    <div class="list-header">
      <div class="list-title"><span id="sourceCount">0个直播源</span> | <span id="uniqueCount">0个唯一源</span> | <span id="validCount">0个有效</span> | <span id="invalidCount">0个失效</span></div>
      <div class="list-actions">
        <span id="selectedCount" class="selected-count" style="display:none">已选: 0</span>
        <button class="btn blue small" id="selectAllValidBtn" style="display:none;padding:6px 12px">全部勾选</button>
        <button class="btn gray small" id="deselectAllValidBtn" style="display:none;padding:6px 12px">全部不勾选</button>
        <button class="btn blue small" id="exportValidBtn" style="display:none;padding:6px 12px">导出选中</button>
      </div>
    </div>
    
    <div class="filter-buttons">
      <button class="filter-btn active" data-filter="all" id="filterAllBtn">全部</button>
      <button class="filter-btn" data-filter="valid" id="filterValidBtn">有效</button>
      <button class="filter-btn" data-filter="invalid" id="filterInvalidBtn">失效</button>
    </div>
    
    <div class="source-list" id="sourceList">
      <div class="empty-list">暂无直播源，请使用上方导入功能</div>
    </div>
  </div>
</div>

<div class="modal" id="networkModal">
  <div class="modal-content">
    <div class="modal-header">网络导入</div>
    <div class="modal-body">
      <input type="text" id="networkUrl" class="url-input" placeholder="输入URL地址">
      <div id="networkStatus" class="status"></div>
      <div style="font-size:clamp(13px, 3vw, 16px);color:#666">
        <p><strong>示例：</strong></p>
        <p style="font-size:clamp(12px, 2.5vw, 14px);word-break:break-all">http:\/\/ybtvsg.yuanbaotv.com\/api\/zip\/txtzztv\/202511061613\/kds_all_shlt_a160216bf6b3c6054c4a71d40132931c.txt</p>
        <p style="font-size:clamp(12px, 2.5vw, 14px);word-break:break-all">https://gitee.com/messy-in-the-win/tv/raw/master/%E5%90%88%E5%B9%B6%E5%9C%B0%E6%96%B9%E5%8F%B0.txt</p>
        <p>支持.txt/.m3u/.m3u8格式</p>
        <p><strong>支持格式：</strong>频道名称,URL 或 分组名称,#genre#分组名称</p>
      </div>
    </div>
    <div class="modal-footer">
      <button class="btn gray" id="cancelImportBtn">取消</button>
      <button class="btn blue" id="confirmImportBtn">导入</button>
    </div>
  </div>
</div>

<div class="modal" id="groupModal">
  <div class="modal-content">
    <div class="modal-header">频道管理</div>
    <div class="modal-body">
      <div class="group-container">
        <p style="font-size:clamp(16px, 4vw, 20px); margin-bottom: 20px; font-weight: bold;">选择要检测的分组（可多选）：</p>
        <div class="group-grid" id="groupCheckboxes"></div>
        <div style="display:flex;flex-wrap:wrap;gap:12px;margin-top:25px;justify-content:center">
          <button class="btn blue" id="selectAllGroupsBtn" style="min-width:150px">全选分组</button>
          <button class="btn gray" id="deselectAllGroupsBtn" style="min-width:150px">取消全选</button>
        </div>
      </div>
    </div>
    <div class="modal-footer">
      <button class="btn gray" id="closeGroupBtn">关闭</button>
      <button class="btn green" id="testSelectedGroupsBtn" style="min-width:180px">检测选中分组</button>
    </div>
  </div>
</div>

<input type="file" id="fileInput" accept=".txt,.m3u,.m3u8" style="display:none">

<script>
// 使用立即执行函数封装，避免全局变量污染
(function() {
  // 缓存DOM元素引用
  const DOM_CACHE = {};
  
  // 性能优化：使用requestAnimationFrame批量更新DOM
  let updateQueue = [];
  let updateAnimationFrameId = null;
  
  const scheduleUpdate = (fn) => {
    updateQueue.push(fn);
    if (!updateAnimationFrameId) {
      updateAnimationFrameId = requestAnimationFrame(() => {
        while (updateQueue.length) {
          updateQueue.shift()();
        }
        updateAnimationFrameId = null;
      });
    }
  };
  
  // 缓存常用函数
  const cached = {
    formatTime: null,
    cleanUrl: null
  };
  
  // 获取DOM元素（带缓存）
  const getElement = (id) => {
    if (!DOM_CACHE[id]) {
      DOM_CACHE[id] = document.getElementById(id);
    }
    return DOM_CACHE[id];
  };
  
  // 数据状态
  const state = {
    data: [],
    selectedGroups: [],
    allGroups: [],
    isDetecting: false,
    detectionStats: { 
      processed: 0, 
      valid: 0, 
      invalid: 0, 
      startTime: 0,
      totalTime: 0
    },
    currentFilter: 'all',
    importData: {
      groupInfo: {},
      sources: {}
    },
    lastUpdateTime: 0,
    updateThrottleTime: 50 // 最小更新间隔50ms
  };
  
  // 工具函数
  const utils = {
    cleanUrl: (u) => {
      if (!cached.cleanUrl) {
        cached.cleanUrl = (url) => url.replace(/\\\//g, '/');
      }
      return cached.cleanUrl(u);
    },
    
    showStatus: (msg, isError) => {
      const el = getElement('networkStatus');
      if (!el) return;
      
      el.textContent = msg;
      el.className = `status ${isError ? 'error' : 'success'}`;
      el.style.display = msg ? 'block' : 'none';
    },
    
    fetchUrl: async (u) => {
      const cleaned = utils.cleanUrl(u);
      const proxies = [
        `https://api.codetabs.com/v1/proxy?quest=${encodeURIComponent(cleaned)}`,
        `https://corsproxy.io/?${encodeURIComponent(cleaned)}`,
        cleaned
      ];
      
      for (let p of proxies) {
        try {
          const c = new AbortController();
          setTimeout(() => c.abort(), 10000);
          const r = await fetch(p, { 
            signal: c.signal, 
            headers: { 'User-Agent': 'Mozilla/5.0' } 
          });
          if (r.ok) return await r.text();
        } catch (e) {
          // 忽略错误，尝试下一个代理
        }
      }
      throw new Error('所有代理均失败');
    },
    
    toggleControls: (enable) => {
      const controls = ['localImportBtn', 'networkImportBtn', 'groupBtn', 'clearBtn'];
      controls.forEach(id => {
        const btn = getElement(id);
        if (btn) btn.disabled = !enable;
      });
      
      document.querySelectorAll('.filter-btn').forEach(btn => {
        btn.disabled = !enable;
      });
      
      const actionBtns = ['selectAllValidBtn', 'deselectAllValidBtn', 'exportValidBtn'];
      actionBtns.forEach(id => {
        const btn = getElement(id);
        if (btn) btn.disabled = !enable;
      });
    },
    
    formatTime: (ms) => {
      if (!cached.formatTime) {
        cached.formatTime = (time) => {
          if (time < 1000) return `${time}ms`;
          if (time < 10000) return `${(time/1000).toFixed(2)}s`;
          return `${(time/1000).toFixed(1)}s`;
        };
      }
      return cached.formatTime(ms);
    },
    
    updateSelectedCount: () => {
      const selectedItems = state.data.filter(item => 
        item.status === 'valid' && item.selected
      );
      const count = selectedItems.length;
      const el = getElement('selectedCount');
      
      if (state.currentFilter === 'valid') {
        el.textContent = `已选: ${count}`;
        el.style.display = 'inline';
        
        ['selectAllValidBtn', 'deselectAllValidBtn'].forEach(id => {
          const btn = getElement(id);
          if (btn) btn.style.display = 'inline-block';
        });
        
        const exportBtn = getElement('exportValidBtn');
        if (exportBtn) exportBtn.style.display = count > 0 ? 'inline-block' : 'none';
      } else {
        el.style.display = 'none';
        ['selectAllValidBtn', 'deselectAllValidBtn', 'exportValidBtn'].forEach(id => {
          const btn = getElement(id);
          if (btn) btn.style.display = 'none';
        });
      }
    },
    
    playVideo: (url, channelName) => {
      const title = getElement('videoTitle');
      const placeholder = getElement('videoPlaceholder');
      const video = getElement('previewVideo');
      
      if (title) title.textContent = channelName || '视频预览';
      if (placeholder) placeholder.style.display = 'none';
      if (video) {
        video.style.display = 'block';
        video.src = utils.cleanUrl(url);
        video.play().catch(e => console.log('自动播放失败:', e));
      }
      
      // 使用平滑滚动
      const preview = getElement('videoPreview');
      if (preview) {
        setTimeout(() => {
          preview.scrollIntoView({ behavior: 'smooth' });
        }, 300);
      }
    },
    
    stopVideo: () => {
      const video = getElement('previewVideo');
      const placeholder = getElement('videoPlaceholder');
      const title = getElement('videoTitle');
      
      if (video) {
        video.pause();
        video.src = '';
        video.style.display = 'none';
      }
      if (placeholder) placeholder.style.display = 'block';
      if (title) title.textContent = '视频预览';
    }
  };
  
  // 核心功能
  const core = {
    // 缓存过滤数据
    cachedFilteredData: null,
    
    getFilteredData: () => {
      // 如果有缓存且数据未变化，直接返回缓存
      if (core.cachedFilteredData) return core.cachedFilteredData;
      
      if (state.currentFilter === 'all') {
        core.cachedFilteredData = state.data;
      } else if (state.currentFilter === 'valid') {
        core.cachedFilteredData = state.data.filter(i => i.status === 'valid');
      } else if (state.currentFilter === 'invalid') {
        core.cachedFilteredData = state.data.filter(i => i.status === 'invalid');
      } else {
        core.cachedFilteredData = state.data;
      }
      
      return core.cachedFilteredData;
    },
    
    // 优化：批量更新统计信息
    updateStats: () => {
      const now = Date.now();
      if (now - state.lastUpdateTime < state.updateThrottleTime) {
        return;
      }
      state.lastUpdateTime = now;
      
      const count = state.data.length;
      const unique = new Set(state.data.map(i => i.url)).size;
      const valid = state.data.filter(i => i.status === 'valid').length;
      const invalid = state.data.filter(i => i.status === 'invalid').length;
      
      const groupsSet = new Set();
      state.data.forEach(i => groupsSet.add(i.group));
      state.allGroups = Array.from(groupsSet);
      
      // 批量更新DOM
      scheduleUpdate(() => {
        const elements = {
          sourceCount: `${count}个直播源`,
          uniqueCount: `${unique}个唯一源`,
          totalCount: count,
          groupCount: state.allGroups.length,
          validCount: `${valid}个有效`,
          invalidCount: `${invalid}个失效`
        };
        
        Object.entries(elements).forEach(([id, value]) => {
          const el = getElement(id);
          if (el) el.textContent = value;
        });
      });
    },
    
    update: () => {
      // 清除缓存
      core.cachedFilteredData = null;
      
      // 更新统计信息
      core.updateStats();
      
      const filteredData = core.getFilteredData();
      const sourceList = getElement('sourceList');
      
      if (!sourceList) return;
      
      // 空列表处理
      if (filteredData.length === 0) {
        let emptyMessage = '暂无直播源';
        if (state.data.length > 0) {
          if (state.currentFilter === 'valid') emptyMessage = '暂无有效直播源';
          else if (state.currentFilter === 'invalid') emptyMessage = '暂无失效直播源';
          else emptyMessage = '请使用上方导入功能';
        }
        
        scheduleUpdate(() => {
          sourceList.innerHTML = `<div class="empty-list">${emptyMessage}</div>`;
        });
        return;
      }
      
      // 使用DocumentFragment批量插入
      scheduleUpdate(() => {
        const fragment = document.createDocumentFragment();
        const now = Date.now();
        
        filteredData.forEach((i, index) => {
          const div = document.createElement('div');
          div.className = 'source-item';
          div.setAttribute('data-index', state.data.indexOf(i));
          
          const showCheckbox = state.currentFilter === 'valid' && i.status === 'valid';
          
          div.innerHTML = `
            ${showCheckbox ? `
              <div class="source-checkbox-label">
                <input type="checkbox" class="source-checkbox" ${i.selected ? 'checked' : ''} ${detector.running ? 'disabled' : ''}>
              </div>
            ` : '<div style="width:22px"></div>'}
            <div class="channel-name">${i.name || i.group}</div>
            <div class="source-url">${i.url}</div>
            <div class="status-container">
              <div class="status-badge status-${i.status}">
                ${i.status === 'valid' ? '有效' : i.status === 'invalid' ? '失效' : '未检'}
              </div>
              ${i.detectionTime ? `
                <div class="detection-time ${i.status}">
                  ${utils.formatTime(i.detectionTime)}
                </div>` : ''}
            </div>
            <button class="play-btn" data-url="${i.url}" data-name="${i.name || i.group}">播放</button>
          `;
          fragment.appendChild(div);
        });
        
        sourceList.innerHTML = '';
        sourceList.appendChild(fragment);
      });
      
      // 更新分组复选框
      core.updateGroupCheckboxes();
      utils.updateSelectedCount();
    },
    
    updateGroupCheckboxes: () => {
      const groupCheckboxes = getElement('groupCheckboxes');
      if (!groupCheckboxes) return;
      
      scheduleUpdate(() => {
        const fragment = document.createDocumentFragment();
        const groupCountMap = new Map();
        
        state.data.forEach(i => {
          groupCountMap.set(i.group, (groupCountMap.get(i.group) || 0) + 1);
        });
        
        state.allGroups.forEach(g => {
          const count = groupCountMap.get(g) || 0;
          const selected = state.selectedGroups.includes(g);
          const div = document.createElement('div');
          div.className = `group-item ${selected ? 'selected' : ''}`;
          div.setAttribute('data-group', g);
          div.innerHTML = `
            <input type="checkbox" class="group-checkbox" ${selected ? 'checked' : ''} ${detector.running ? 'disabled' : ''}>
            <div class="group-name">${g}</div>
            <div class="group-count">${count}个源</div>
          `;
          fragment.appendChild(div);
        });
        
        groupCheckboxes.innerHTML = '';
        groupCheckboxes.appendChild(fragment);
      });
    },
    
    toggleGroup: (g) => {
      if (detector.running) return;
      const idx = state.selectedGroups.indexOf(g);
      idx > -1 ? state.selectedGroups.splice(idx, 1) : state.selectedGroups.push(g);
      core.updateGroupCheckboxes();
    },
    
    extractUrls: (t) => {
      const result = [];
      let currentGroup = '默认分组';
      const lines = t.split('\n');
      const urlSet = new Set();
      
      state.importData = {
        groupInfo: {},
        sources: {}
      };
      
      // 第一遍：收集分组信息
      for (let line of lines) {
        const originalLine = line;
        line = line.trim();
        if (!line) continue;
        
        if (line.includes(',#genre#')) {
          const match = line.match(/^(.*),#genre#(.*)$/);
          if (match) {
            currentGroup = (match[2] || match[1]).trim();
            state.importData.groupInfo[currentGroup] = originalLine;
          }
        }
      }
      
      currentGroup = '默认分组';
      
      // 第二遍：提取URL
      for (let line of lines) {
        const originalLine = line;
        line = line.trim();
        if (!line) continue;
        
        if (line.includes(',#genre#')) {
          const match = line.match(/^(.*),#genre#(.*)$/);
          if (match) {
            currentGroup = (match[2] || match[1]).trim();
          }
          continue;
        }
        
        if (line.startsWith('#') || line.startsWith('//')) continue;
        
        const commaIndex = line.indexOf(',');
        let channelName = currentGroup;
        let urlPart = line;
        
        if (commaIndex !== -1) {
          channelName = line.substring(0, commaIndex).trim();
          urlPart = line.substring(commaIndex + 1).trim();
        }
        
        const matches = urlPart.match(/(https?:\/\/[^\s<>"']+)/gi);
        if (matches) {
          for (let u of matches) {
            u = u.replace(/[\s,;'"`]+$/, '');
            if (u.length > 10 && !urlSet.has(u)) {
              urlSet.add(u);
              const item = { 
                name: channelName,
                url: u, 
                group: currentGroup, 
                status: 'unknown',
                detectionTime: 0,
                selected: false
              };
              result.push(item);
              
              state.importData.sources[u] = {
                originalLine: originalLine,
                group: currentGroup,
                name: channelName
              };
            }
          }
        }
      }
      
      return result;
    },
    
    addSources: (items) => {
      const oldCount = state.data.length;
      const urlSet = new Set(state.data.map(d => d.url));
      const newGroups = new Set();
      
      for (let item of items) {
        if (!urlSet.has(item.url)) {
          urlSet.add(item.url);
          state.data.push(item);
          newGroups.add(item.group);
        }
      }
      
      // 清除缓存
      core.cachedFilteredData = null;
      
      return { added: state.data.length - oldCount, newGroups: newGroups.size };
    },
    
    updateFilterButtons: () => {
      document.querySelectorAll('.filter-btn').forEach(btn => {
        if (btn.getAttribute('data-filter') === state.currentFilter) {
          btn.classList.add('active');
        } else {
          btn.classList.remove('active');
        }
      });
    },
    
    selectAllValid: () => {
      state.data.forEach(item => {
        if (item.status === 'valid') {
          item.selected = true;
        }
      });
      core.update();
    },
    
    deselectAllValid: () => {
      state.data.forEach(item => {
        if (item.status === 'valid') {
          item.selected = false;
        }
      });
      core.update();
    },
    
    generateExportContent: (selectedItems) => {
      const lines = [];
      const groupsMap = new Map();
      
      selectedItems.forEach(item => {
        const url = item.url;
        const group = item.group;
        
        if (!groupsMap.has(group)) {
          groupsMap.set(group, []);
        }
        
        if (state.importData.sources[url]) {
          groupsMap.get(group).push(state.importData.sources[url].originalLine);
        } else {
          groupsMap.get(group).push(`${item.name || item.group},${item.url}`);
        }
      });
      
      const allGroups = Array.from(groupsMap.keys());
      
      allGroups.forEach(group => {
        if (state.importData.groupInfo[group]) {
          lines.push(state.importData.groupInfo[group]);
        } else if (group !== '默认分组') {
          lines.push(`${group},#genre#${group}`);
        }
        
        const channels = groupsMap.get(group);
        channels.forEach(channel => {
          lines.push(channel);
        });
      });
      
      return lines.join('\n');
    }
  };
  
  // 检测器（保持不变）
  const detector = {
    queue: [],
    workers: [],
    timeout: 5000,
    delay: 200,  // 默认值已通过HTML设置，这里会在init中读取
    concurrency: 10,
    running: false,
    
    init: () => {
      const timeoutSlider = getElement('timeoutSlider');
      const delaySlider = getElement('delaySlider');
      const concurrencySlider = getElement('concurrencySlider');
      const timeoutValue = getElement('timeoutValue');
      const delayValue = getElement('delayValue');
      const concurrencyValue = getElement('concurrencyValue');
      
      if (timeoutSlider) {
        timeoutSlider.oninput = () => {
          detector.timeout = parseInt(timeoutSlider.value) * 1000;
          if (timeoutValue) timeoutValue.textContent = timeoutSlider.value + '秒';
        };
      }
      
      if (delaySlider) {
        delaySlider.oninput = () => {
          detector.delay = parseInt(delaySlider.value);
          if (delayValue) delayValue.textContent = delaySlider.value + 'ms';
        };
      }
      
      if (concurrencySlider) {
        concurrencySlider.oninput = () => {
          detector.concurrency = parseInt(concurrencySlider.value);
          if (concurrencyValue) concurrencyValue.textContent = concurrencySlider.value + '个';
        };
      }
      
      detector.timeout = parseInt(timeoutSlider?.value || 5) * 1000;
      detector.delay = parseInt(delaySlider?.value || 200);  // 读取HTML中的默认值200
      detector.concurrency = parseInt(concurrencySlider?.value || 10);
    },
    
    testSource: async (source, index) => {
      return new Promise((resolve) => {
        const startTime = Date.now();
        const video = document.createElement('video');
        video.style.display = 'none';
        document.body.appendChild(video);
        
        let timeoutId, resolved = false;
        
        const cleanup = () => {
          if (resolved) return;
          resolved = true;
          clearTimeout(timeoutId);
          video.pause();
          video.src = '';
          video.load();
          document.body.removeChild(video);
        };
        
        const onSuccess = () => {
          if (resolved) return;
          const detectionTime = Date.now() - startTime;
          cleanup();
          resolve({ index, status: 'valid', detectionTime });
        };
        
        const onError = () => {
          if (resolved) return;
          const detectionTime = Date.now() - startTime;
          cleanup();
          resolve({ index, status: 'invalid', detectionTime });
        };
        
        timeoutId = setTimeout(() => {
          if (resolved) return;
          const detectionTime = Date.now() - startTime;
          cleanup();
          resolve({ index, status: 'invalid', detectionTime });
        }, detector.timeout);
        
        video.addEventListener('canplay', onSuccess, { once: true });
        video.addEventListener('loadedmetadata', onSuccess, { once: true });
        video.addEventListener('error', onError, { once: true });
        video.addEventListener('stalled', onError, { once: true });
        
        video.src = utils.cleanUrl(source.url);
        video.load();
        video.play().catch(() => {});
      });
    },
    
    updateProgress: () => {
      const total = detector.queue.length;
      const processed = state.detectionStats.processed;
      const progress = total > 0 ? (processed / total) * 100 : 0;
      
      scheduleUpdate(() => {
        const progressFill = getElement('progressFill');
        if (progressFill) progressFill.style.width = `${progress}%`;
        
        const elements = {
          processedCount: processed,
          validDetectedCount: state.detectionStats.valid,
          invalidDetectedCount: state.detectionStats.invalid
        };
        
        Object.entries(elements).forEach(([id, value]) => {
          const el = getElement(id);
          if (el) el.textContent = value;
        });
        
        if (state.detectionStats.startTime > 0) {
          const elapsed = (Date.now() - state.detectionStats.startTime) / 1000;
          const speed = elapsed > 0 ? Math.round(processed / elapsed) : 0;
          const speedEl = getElement('speedValue');
          if (speedEl) speedEl.textContent = speed;
          
          if (state.detectionStats.totalTime > 0 && processed > 0) {
            const avgTime = Math.round(state.detectionStats.totalTime / processed);
            const avgTimeEl = getElement('avgTimeValue');
            if (avgTimeEl) avgTimeEl.textContent = utils.formatTime(avgTime);
          }
        }
      });
      
      core.update();
    },
    
    processResult: (result) => {
      const { index, status, detectionTime } = result;
      const source = state.data[index];
      
      if (source) {
        source.status = status;
        source.detectionTime = detectionTime;
        
        state.detectionStats.processed++;
        state.detectionStats.totalTime += detectionTime;
        
        if (status === 'valid') {
          state.detectionStats.valid++;
        } else {
          state.detectionStats.invalid++;
        }
        
        detector.updateProgress();
      }
    },
    
    worker: async () => {
      while (detector.running && detector.queue.length > 0) {
        const task = detector.queue.shift();
        if (!task) break;
        
        const result = await detector.testSource(task.source, task.index);
        detector.processResult(result);
        
        if (detector.delay > 0 && detector.queue.length > 0) {
          await new Promise(resolve => setTimeout(resolve, detector.delay));
        }
      }
    },
    
    start: async () => {
      if (detector.running || state.data.length === 0) return;
      
      detector.running = true;
      state.detectionStats = {
        processed: 0,
        valid: 0,
        invalid: 0,
        startTime: Date.now(),
        totalTime: 0
      };
      
      scheduleUpdate(() => {
        const avgTimeEl = getElement('avgTimeValue');
        if (avgTimeEl) avgTimeEl.textContent = '0ms';
      });
      
      utils.toggleControls(false);
      
      const testBtn = getElement('testBtn');
      if (testBtn) {
        testBtn.textContent = '停止检测';
        testBtn.classList.remove('green');
        testBtn.classList.add('red');
      }
      
      detector.queue = state.data.map((source, index) => ({ source, index }));
      
      detector.workers = [];
      const workerCount = Math.min(detector.concurrency, detector.queue.length);
      
      for (let i = 0; i < workerCount; i++) {
        detector.workers.push(detector.worker());
      }
      
      try {
        await Promise.all(detector.workers);
      } catch (error) {
        console.error('检测过程中出错:', error);
      }
      
      detector.stop();
    },
    
    stop: () => {
      detector.running = false;
      detector.queue = [];
      detector.workers = [];
      
      utils.toggleControls(true);
      
      const testBtn = getElement('testBtn');
      if (testBtn) {
        testBtn.textContent = '开始检测';
        testBtn.classList.remove('red');
        testBtn.classList.add('green');
      }
      
      core.selectAllValid();
      
      if (state.detectionStats.processed > 0) {
        const avgTime = state.detectionStats.totalTime > 0 ? 
          Math.round(state.detectionStats.totalTime / state.detectionStats.processed) : 0;
        
        scheduleUpdate(() => {
          alert(`检测完成！\n已处理: ${state.detectionStats.processed}个\n有效: ${state.detectionStats.valid}个\n失效: ${state.detectionStats.invalid}个\n平均耗时: ${utils.formatTime(avgTime)}`);
        });
      }
    }
  };
  
  // 事件处理
  const events = {
    init: () => {
      detector.init();
      
      // 事件委托优化：统一处理点击事件
      document.addEventListener('click', (e) => {
        const target = e.target;
        
        // 播放按钮
        if (target.classList.contains('play-btn')) {
          const url = target.getAttribute('data-url');
          const name = target.getAttribute('data-name');
          if (url) utils.playVideo(url, name);
          return;
        }
        
        // 复选框
        if (target.classList.contains('source-checkbox')) {
          if (detector.running) return;
          const sourceItem = target.closest('.source-item');
          if (sourceItem) {
            const index = parseInt(sourceItem.getAttribute('data-index'));
            if (!isNaN(index) && index >= 0 && index < state.data.length) {
              const item = state.data[index];
              if (item.status === 'valid') {
                item.selected = target.checked;
                utils.updateSelectedCount();
              }
            }
          }
          return;
        }
        
        // 分组复选框
        if (target.classList.contains('group-checkbox') || target.closest('.group-item')) {
          if (detector.running) return;
          const groupItem = target.closest('.group-item');
          if (groupItem) {
            const group = groupItem.getAttribute('data-group');
            if (group) core.toggleGroup(group);
          }
          return;
        }
        
        // 过滤按钮
        if (target.classList.contains('filter-btn')) {
          if (detector.running) return;
          const filter = target.getAttribute('data-filter');
          if (filter) {
            state.currentFilter = filter;
            core.updateFilterButtons();
            core.update();
          }
          return;
        }
      });
      
      // 按钮事件绑定
      const bindButton = (id, handler) => {
        const btn = getElement(id);
        if (btn) btn.onclick = handler;
      };
      
      bindButton('testBtn', () => {
        if (state.data.length === 0) {
          alert('请先导入直播源');
          return;
        }
        detector.running ? detector.stop() : detector.start();
      });
      
      bindButton('clearBtn', () => {
        if (detector.running) {
          alert('检测过程中不能清空列表');
          return;
        }
        if (state.data.length && confirm('清空所有直播源？')) {
          state.data = [];
          state.selectedGroups = [];
          state.importData = { groupInfo: {}, sources: {} };
          detector.stop();
          utils.stopVideo();
          core.update();
        }
      });
      
      bindButton('localImportBtn', () => {
        if (detector.running) {
          alert('检测过程中不能导入');
          return;
        }
        getElement('fileInput').click();
      });
      
      bindButton('networkImportBtn', () => {
        if (detector.running) {
          alert('检测过程中不能导入');
          return;
        }
        const networkUrl = getElement('networkUrl');
        const networkStatus = getElement('networkStatus');
        const modal = getElement('networkModal');
        
        if (networkUrl) networkUrl.value = '';
        if (networkStatus) networkStatus.style.display = 'none';
        if (modal) {
          modal.style.display = 'block';
          if (networkUrl) networkUrl.focus();
        }
      });
      
      bindButton('groupBtn', () => {
        if (detector.running) {
          alert('检测过程中不能管理分组');
          return;
        }
        state.selectedGroups = [...state.allGroups];
        const modal = getElement('groupModal');
        if (modal) modal.style.display = 'block';
        core.updateGroupCheckboxes();
      });
      
      bindButton('closeGroupBtn', () => {
        const modal = getElement('groupModal');
        if (modal) modal.style.display = 'none';
      });
      
      bindButton('cancelImportBtn', () => {
        const modal = getElement('networkModal');
        const confirmBtn = getElement('confirmImportBtn');
        if (modal) modal.style.display = 'none';
        if (confirmBtn) confirmBtn.disabled = false;
      });
      
      // 文件输入
      const fileInput = getElement('fileInput');
      if (fileInput) {
        fileInput.onchange = (e) => {
          if (detector.running) {
            alert('检测过程中不能导入');
            fileInput.value = '';
            return;
          }
          
          const file = e.target.files[0];
          if (!file) return;
          
          const reader = new FileReader();
          reader.onload = (e) => {
            const items = core.extractUrls(e.target.result);
            const result = core.addSources(items);
            if (result.added > 0) {
              alert(`导入${result.added}个直播源，新增${result.newGroups}个分组`);
              core.update();
            }
          };
          reader.readAsText(file);
          fileInput.value = '';
        };
      }
      
      bindButton('confirmImportBtn', async () => {
        if (detector.running) {
          alert('检测过程中不能导入');
          return;
        }
        
        const networkUrl = getElement('networkUrl');
        if (!networkUrl) return;
        
        const url = networkUrl.value.trim();
        const cleaned = utils.cleanUrl(url);
        
        if (!url) {
          utils.showStatus('请输入URL', true);
          return;
        }
        
        if (!cleaned.startsWith('http://') && !cleaned.startsWith('https://')) {
          utils.showStatus('URL格式错误', true);
          return;
        }
        
        utils.showStatus('', false);
        const confirmBtn = getElement('confirmImportBtn');
        if (confirmBtn) confirmBtn.disabled = true;
        
        try {
          const text = await utils.fetchUrl(url);
          if (!text) throw new Error('内容为空');
          
          const items = core.extractUrls(text);
          if (items.length === 0) throw new Error('未找到有效URL');
          
          const result = core.addSources(items);
          utils.showStatus(`导入${result.added}个直播源，新增${result.newGroups}个分组`, false);
          core.update();
          
          setTimeout(() => {
            const modal = getElement('networkModal');
            if (modal && modal.style.display === 'block') modal.style.display = 'none';
          }, 2000);
        } catch (e) {
          let msg = '导入失败: ';
          if (e.message.includes('失败')) msg += '无法访问URL';
          else if (e.message.includes('fetch')) msg += '网络错误';
          else msg += e.message;
          utils.showStatus(msg, true);
        }
        
        if (confirmBtn) confirmBtn.disabled = false;
      });
      
      bindButton('selectAllGroupsBtn', () => {
        if (detector.running) return;
        state.selectedGroups = [...state.allGroups];
        core.updateGroupCheckboxes();
      });
      
      bindButton('deselectAllGroupsBtn', () => {
        if (detector.running) return;
        state.selectedGroups = [];
        core.updateGroupCheckboxes();
      });
      
      bindButton('testSelectedGroupsBtn', async () => {
        if (detector.running) {
          alert('检测过程中不能开始新检测');
          return;
        }
        
        if (state.selectedGroups.length === 0) {
          alert('请至少选择一个分组');
          return;
        }
        
        const sources = state.data.filter(i => state.selectedGroups.includes(i.group));
        if (sources.length === 0) {
          alert('选中的分组没有直播源');
          return;
        }
        
        const originalData = [...state.data];
        const originalSelected = [...state.selectedGroups];
        state.data = sources;
        state.selectedGroups = [...new Set(sources.map(s => s.group))];
        await detector.start();
        state.data = originalData;
        state.selectedGroups = originalSelected;
        core.update();
        
        const modal = getElement('groupModal');
        if (modal) modal.style.display = 'none';
      });
      
      bindButton('selectAllValidBtn', () => {
        if (detector.running) return;
        core.selectAllValid();
      });
      
      bindButton('deselectAllValidBtn', () => {
        if (detector.running) return;
        core.deselectAllValid();
      });
      
      // 模态框点击外部关闭
      const modals = ['networkModal', 'groupModal'];
      modals.forEach(modalId => {
        const modal = getElement(modalId);
        if (modal) {
          modal.onclick = (e) => {
            if (e.target === modal) {
              modal.style.display = 'none';
              const confirmBtn = getElement('confirmImportBtn');
              if (confirmBtn) confirmBtn.disabled = false;
            }
          };
        }
      });
      
      // ESC键关闭模态框
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
          modals.forEach(modalId => {
            const modal = getElement(modalId);
            if (modal && modal.style.display === 'block') {
              modal.style.display = 'none';
              const confirmBtn = getElement('confirmImportBtn');
              if (confirmBtn) confirmBtn.disabled = false;
            }
          });
        }
      });
      
      bindButton('exportValidBtn', () => {
        if (detector.running) return;
        
        const selectedItems = state.data.filter(item => 
          item.status === 'valid' && item.selected
        );
        
        if (selectedItems.length === 0) {
          alert('请先在有效列表中选择要导出的直播源');
          return;
        }
        
        const content = core.generateExportContent(selectedItems);
        const blob = new Blob([content], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = '有效直播源.txt';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        alert(`成功导出${selectedItems.length}个有效直播源`);
      });
      
      bindButton('closeVideoBtn', () => {
        utils.stopVideo();
      });
      
      core.update();
    }
  };
  
  // 初始化
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', events.init);
  } else {
    events.init();
  }
})();
</script>
</body>
</html>
